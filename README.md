# ğŸŒŸ KISWARM v4.7 â€” Experience Feedback Loop Â· Self-Hardening Â· SysAdmin Agent

> **ETERNAL SWARM EVOLUTION SYSTEM** â€” Enterprise Military Standard Edition  
> *Production-Hardened Â· Self-Healing Â· Self-Hardening Â· 1344 Tests Â· Every failure makes the next install smarter*  
> **Architect:** Baron Marco Paolo Ialongo

[![Version](https://img.shields.io/badge/version-4.7-FeedbackLoop-blue.svg)](https://github.com/Baronki2/KISWARM)
[![Tests](https://img.shields.io/badge/tests-1344%20passing-brightgreen.svg)](tests/)
[![Modules](https://img.shields.io/badge/modules-45-orange.svg)](python/sentinel/)
[![Endpoints](https://img.shields.io/badge/endpoints-242-purple.svg)](python/sentinel/sentinel_api.py)
[![Install](https://img.shields.io/badge/install-one--click-gold.svg)](install.sh)
[![Feedback](https://img.shields.io/badge/feedback-loop-active-red.svg)](experience/)
[![CI](https://github.com/Baronki2/KISWARM/actions/workflows/ci.yml/badge.svg)](https://github.com/Baronki2/KISWARM/actions/workflows/ci.yml)
[![Tests](https://img.shields.io/badge/tests-1121%20passing-success.svg)](tests/)
[![Status](https://img.shields.io/badge/status-Production%20Ready-brightgreen.svg)](README.md)
[![Endpoints](https://img.shields.io/badge/REST%20endpoints-148-orange.svg)](python/sentinel/sentinel_api.py)
[![Modules](https://img.shields.io/badge/AI%20modules-30-purple.svg)](python/sentinel/)

---

## ğŸ¯ What is KISWARM?

KISWARM is a **complete, self-managing AI governance + industrial cognitive platform** that combines:
- **Autonomous AI Swarm** â€” 27+ local LLM models via Ollama with persistent vector memory
- **CIEC Cognitive Industrial Core** â€” PLC semantic understanding, SCADA observation, digital twin physics, constraint safety, cross-project knowledge graph, and bounded constrained RL

Running **100% locally**, zero cloud dependency. Pure engineering. No philosophy.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 KISWARM v4.0 COMPLETE ARCHITECTURE               â”‚
â”‚                 CIEC + SWARM INTELLIGENCE PLATFORM               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                          â–¼                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ VM-1    â”‚             â”‚ VM-2     â”‚             â”‚ VM-3           â”‚
â”‚ PLC +   â”‚â—„â”€â”€OPC UAâ”€â”€â”€â–ºâ”‚ CIEC     â”‚â—„â”€â”€REST APIâ”€â–ºâ”‚ Digital Twin   â”‚
â”‚ SCADA   â”‚             â”‚ Core     â”‚             â”‚ Physics Engine â”‚
â”‚ Runtime â”‚             â”‚ (Port    â”‚             â”‚ Simulation     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ 11436)   â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                     â–¼                     â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Ollama   â”‚          â”‚ Qdrant   â”‚          â”‚ Tool     â”‚
   â”‚ :11434   â”‚          â”‚ Memory   â”‚          â”‚ Proxy    â”‚
   â”‚ 27+      â”‚          â”‚ Vector   â”‚          â”‚ :11435   â”‚
   â”‚ Models   â”‚          â”‚ DB       â”‚          â”‚ Flask    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Core Design Principle:**
```
PLC  = deterministic reflex layer   (never touched by AI)
CIEC = adaptive cognition layer     (sits above PLC, observes, suggests)
Never invert that hierarchy.
```

---

## ğŸ†• v4.0 CIEC â€” What's New (6 New Modules, 21 New Endpoints, 120 New Tests)

| Module | Name | Purpose |
|---|---|---|
| **11** | PLC Semantic Parser | IEC 61131-3 ST â†’ CIR + DSG + PID/interlock/watchdog |
| **12** | SCADA/OPC Observer | Real-time tag streaming + SQL historian + state vector |
| **13** | Digital Twin Physics | Thermal Â· Pump Â· Battery Â· Power Â· Fault injection |
| **14** | Rule Constraint Engine | Absolute safety layer â€” overrides all RL/fuzzy output |
| **15** | Knowledge Graph | Cross-project PID configs Â· failure signatures Â· federated sync |
| **16** | Industrial Actor-Critic RL | Constrained bounded parameter-shift optimization |

---

## âœ¨ Feature Matrix â€” All Versions (v1.1 â†’ v4.3)

| Feature | v1.1 | v2.1 | v2.2 | v3.0 | v4.0 | v4.1 | v4.2 | **v4.3** |
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| Persistent Vector Memory (Qdrant) | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Tool Injection Proxy (:11435) | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Monitoring Dashboard | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Self-Healing (Systemd) | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Governance + Audit Logging | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| 27+ Ollama Models | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Test Coverage | 111 | 148 | 205 | 310 | 430 | 572 | 729 | **948** |
| REST API Endpoints | â€” | 5 | 17 | 29 | 59 | 99 | 133 | **148** |
| Sentinel Bridge (AKE) | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Swarm Debate Engine | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Semantic Conflict Detection | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Knowledge Decay Engine | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Cryptographic Knowledge Ledger | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Adversarial Prompt Firewall | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| Fuzzy Membership Auto-Tuner | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… |
| Constrained RL (CMDP) | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… |
| Digital Twin Mutation Pipeline | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… |
| Federated Adaptive Mesh | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… | âœ… |
| PLC Semantic Parser | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… |
| SCADA/OPC Observer | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… |
| Physics Twin Engine | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… |
| Rule Constraint Engine | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… |
| Cross-Project Knowledge Graph | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… |
| Industrial Actor-Critic RL | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… | âœ… |
| TD3 Industrial Controller | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| IEC 61131-3 AST Parser | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| Extended Physics Twin (RK4) | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| VMware Orchestration | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| Formal Stability Verification | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| Byzantine Federated Aggregation | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| 11-Step Mutation Governance | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… | âœ… |
| XAI / KernelSHAP Explainability | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… |
| Predictive Maintenance (RUL) | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… |
| Multi-Agent Plant Coordinator | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… |
| IEC 61508 SIL Verification | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… |
| Digital Thread Tracker | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âœ… | âœ… |
| **ICS Cybersecurity (IEC 62443)** | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | **âœ… NEW** |
| **OT Network Monitor (passive)** | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | âŒ | **âœ… NEW** |

---

## ğŸš€ Quick Start â€” 3 Commands

```bash
# 1. Clone the repository
git clone https://github.com/Baronki2/KISWARM.git && cd KISWARM

# 2. Run the 10-phase automated deployment (15â€“20 minutes)
chmod +x deploy/kiswarm_deploy.sh && ./deploy/kiswarm_deploy.sh

# 3. Activate and verify
source ~/.bashrc && kiswarm-health && sys-nav
```

**System is fully operational when you see:** `Overall Health: 90%+` âœ…

---

## âš™ï¸ v4.0 CIEC â€” SIX COGNITIVE INDUSTRIAL MODULES

> *"You are not building AI that controls a plant. You are building a Cognitive Overlay Engine sitting on top of deterministic PLC infrastructure."*

---

### Module 11 â€” PLC Semantic Parser (`plc_parser.py`)

Understands existing PLC logic without touching it. Parses **IEC 61131-3 Structured Text** into a structured semantic representation.

**Three-stage pipeline:**

```
Stage 1 â€” Tokenize
  Raw ST source â†’ token stream
  Handles: PROGRAM/END_PROGRAM, VAR blocks, IF/ELSE/END_IF,
           function calls, assignments, expressions

Stage 2 â€” Build CIR (Canonical Intermediate Representation)
  Token stream â†’ CIR Nodes
  
  CIRNode {
    node_id:    "N0012"
    node_type:  IF | ASSIGN | FB_CALL | COMPARE | TON | ...
    inputs:     [signal names read]
    outputs:    [signals written]
    safety_flag: True if condition involves E-STOP/FAULT/etc.
    params:     {condition, rhs, ...}
  }

Stage 3 â€” Build DSG (Directed Signal Graph)
  CIR nodes â†’ directed edges (data flow)
  Feedback detection: output of node A â†’ input of node A (control loop)
```

**Pattern detectors:**

| Pattern | What it finds |
|---|---|
| PID blocks | `PID(SP:=..., PV:=..., KP:=..., KI:=..., KD:=...)` |
| Interlocks | IF-conditions referencing ESTOP/FAULT/SAFETY signals |
| Watchdogs | WD_* named instances, TON/WD timers |
| Safety flags | BOOL variables with E-STOP/SAFETY/ALARM in name |

```python
parser = PLCSemanticParser()
result = parser.parse(st_source_code, "PumpControl")

result.pid_blocks[0].kp          # 1.2
result.interlocks[0].condition   # "ESTOP OR fault_flag"
result.watchdogs[0].type         # "watchdog_timer"
result.source_hash               # SHA-256[:16] for KG linking
```

**REST API:**
```bash
curl -X POST http://localhost:11436/plc/parse \
  -d '{"source": "PROGRAM PumpCtrl\n...\nEND_PROGRAM", "program_name": "PumpCtrl"}'

curl http://localhost:11436/plc/stats
```

---

### Module 12 â€” SCADA/OPC/SQL Observer (`scada_observer.py`)

Observes live plant state without binding to RS-485 drivers.

**Data ingestion:**

```
OPC UA real-time:   push_reading("temperature", 45.2, timestamp)
OPC snapshot:       push_snapshot({"pressure": 3.0, "flow": 12.5})
SQL historian:      ingest_history([{"tag": "t1", "value": 1.0, "timestamp": ...}])
```

**Feature extraction (12 features per tag):**

```
TagFeatures {
  mean              overshoot_ratio
  variance          settling_time_estimate
  min / max         thermal_drift
  switching_freq    deadband_crossings
  actuator_cycles   utilization_rate
  derivative        peak_load
}
```

**State vector builder:**

```
S(t) = [timestamp, alarm_count, featâ‚...featâ‚â‚‚, featâ‚...featâ‚â‚‚, ...]
                                â†â”€â”€â”€â”€â”€ 12 per tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
```

**REST API:**
```bash
curl -X POST http://localhost:11436/scada/push -d '{"tag":"pressure","value":3.2}'
curl -X POST http://localhost:11436/scada/ingest-history -d '{"records":[...]}'
curl http://localhost:11436/scada/state
curl "http://localhost:11436/scada/anomalies?threshold=3.0"
```

---

### Module 13 â€” Digital Twin Physics Engine (`physics_twin.py`)

Simulates plant physics **without touching real actuators**. Mutation candidates are validated here before any deployment.

**Four physics modules:**

```
ThermalState:
  dT/dt = (Q_in âˆ’ k_loss Ã— (T âˆ’ T_env)) / C_thermal
  T_{t+1} = T_t + Î”t Ã— dT/dt

PumpState (Bernoulli):
  flow = k_flow Ã— âˆš(Î”P)
  cavitation = NPSH_available < NPSH_required

BatteryState (Hybrid ECM):
  SOC_{t+1} = SOC_t + (I_charge âˆ’ I_discharge) / Capacity
  V = OCV(SOC) âˆ’ I Ã— R_internal
  Thermal: dT/dt = (IÂ²R âˆ’ cooling) / C

PowerRoutingState:
  P_mismatch = Î£loads âˆ’ Î£generation
  Î”f â‰ˆ P_mismatch / (2 Ã— H_inertia)
```

**Fault injection engine:**

| Fault Category | Examples |
|---|---|
| Sensor faults | stuck-at Â· drift Â· noise spike |
| Actuator faults | delayed response Â· partial fail Â· full fail |
| Physical faults | heat exchanger drop Â· cavitation Â· battery resistance rise |

**Mutation evaluation pipeline:**
```python
twin = PhysicsTwin()
promote, metrics = twin.evaluate_mutation(
    {"q_in": 2200, "dp": 2.5},
    n_runs=5   # Monte Carlo over n independent episodes
)
# promote = True only if: zero hard violations + improved survival score
```

**REST API:**
```bash
curl -X POST http://localhost:11436/ciec-twin/run \
  -d '{"steps":100,"dt":0.1,"inject_faults":true}'
curl -X POST http://localhost:11436/ciec-twin/evaluate \
  -d '{"params":{"q_in":2200,"dp":2.5},"n_runs":5}'
```

---

### Module 14 â€” Rule Constraint Engine (`rule_engine.py`)

**Absolute safety layer.** Sits between RL output and the PLC parameter space. Hard constraints block actions entirely. Soft constraints penalize the RL reward.

**Built-in constraints (10 default):**

| Constraint | Type | Condition | Penalty |
|---|---|---|---|
| `OVERPRESSURE_BLOCK` | Hard | pressure > 8 bar | 10â¶ |
| `BATTERY_CRITICAL_BLOCK` | Hard | SOC < 15% | 10â¶ |
| `OVERTEMP_BLOCK` | Hard | temperature > 95Â°C | 10â¶ |
| `FREQUENCY_DEVIATION_BLOCK` | Hard | |f âˆ’ 50Hz| > 2.5 | 10â¶ |
| `ACTUATOR_WEAR_BLOCK` | Hard | wear_index > 0.95 | 10â¶ |
| `PID_KP_BOUND` | Hard | |Î”kp| > 5% | 10â¶ |
| `PID_KI_BOUND` | Hard | |Î”ki| > 5% | 10â¶ |
| `HIGH_PRESSURE_WARNING` | Soft | pressure > 6.5 bar | 500 |
| `RELAY_OVERCYCLING_PENALTY` | Soft | switching > 2 Hz | 200 |
| `BATTERY_LOW_WARNING` | Soft | SOC < 25% | 300 |

**Action clamping** â€” even if constraint allows, action is bounded:
```
delta_kp, delta_ki, delta_kd  âˆˆ [âˆ’5%, +5%]
delta_threshold                âˆˆ [âˆ’10%, +10%]
delta_schedule                 âˆˆ [âˆ’20%, +20%]
delta_energy_w                 âˆˆ [âˆ’15%, +15%]
```

```python
engine = RuleConstraintEngine()
result = engine.validate(state, action)
# result.allowed         True/False
# result.hard_violations ["OVERPRESSURE_BLOCK", ...]
# result.total_penalty   1000000.0
# result.action_after    clamped action dict
# result.check_time_us   < 100Î¼s typical
```

**REST API:**
```bash
curl -X POST http://localhost:11436/constraints/validate \
  -d '{"state":{"pressure":3.2,"battery_soc":0.85},"action":{"delta_kp":0.02}}'
curl -X POST http://localhost:11436/constraints/check-state \
  -d '{"state":{"pressure":9.5}}'   # â†’ {"safe": false}
curl http://localhost:11436/constraints/list
curl http://localhost:11436/constraints/stats
```

---

### Module 15 â€” Cross-Project Knowledge Graph (`knowledge_graph.py`)

The **real differentiator.** Learns across multiple PLC versions, sites, and years. Detects: *"You solved this pump cavitation 4 times in 8 years. Here is the unified design block."*

**Node types:**

| Kind | Contains |
|---|---|
| `PIDConfig` | Proven Kp/Ki/Kd + plant type + performance history |
| `FailureSig` | Symptom list + root cause + fix template |
| `OptTemplate` | Problem class + solution + measured gain |
| `DesignBlock` | Reusable functional block pattern |
| `PlantProfile` | Site-specific plant characteristics |

**Similarity engine:**
```
cosine_sim(vâ‚, vâ‚‚) = (vâ‚Â·vâ‚‚) / (|vâ‚|Ã—|vâ‚‚|)
jaccard_sim(tâ‚, tâ‚‚) = |tâ‚âˆ©tâ‚‚| / |tâ‚âˆªtâ‚‚|   (tag overlap)
combined = 0.7 Ã— cosine + 0.3 Ã— jaccard
```

**Federated sync (no raw telemetry ever transmitted):**
```python
# Site A exports signed diff bundle
bundle = site_a_kg.export_diff_bundle(since_timestamp=last_sync)
# bundle_sig = SHA-256(site_id + timestamp + nodes)[:24]

# Site B imports and verifies
imported = site_b_kg.import_diff_bundle(bundle)
# 0 if signature fails â†’ never imports unsigned knowledge
```

```python
kg = KnowledgeGraph(site_id="PLANT_MUNICH")
node = kg.add_pid_config("Pump-A PID", kp=1.2, ki=0.3, kd=0.05, ...)
matches = kg.find_by_symptoms(["pressure_drop", "high_vibration"])
patterns = kg.detect_recurring_patterns(min_occurrences=2)
# patterns[0] â†’ {"symptom_set": ["pressure_drop"], "occurrences": 4, "sites": [...]}
```

**REST API:**
```bash
curl -X POST http://localhost:11436/kg/add-pid \
  -d '{"title":"Pump PID","kp":1.2,"ki":0.3,"kd":0.05,"plant_type":"pump"}'
curl -X POST http://localhost:11436/kg/find-by-symptoms \
  -d '{"symptoms":["pressure_drop","vibration"]}'
curl http://localhost:11436/kg/recurring-patterns?min_occurrences=2
curl http://localhost:11436/kg/export-bundle
curl -X POST http://localhost:11436/kg/import-bundle -d '{"bundle":{...}}'
```

---

### Module 16 â€” Industrial Actor-Critic RL (`actor_critic.py`)

**Constrained Actor-Critic with Lagrangian Penalty** â€” specifically designed for industrial parameter mutation, not generic RL.

**Architecture:**
```
State S_t âˆˆ â„^N (150â€“600 features)
   â†“
SharedEncoder: Dense(64,ReLU) â†’ Dense(64,ReLU) â†’ Z_t (64-dim)
   â†™                                              â†˜
ActorHead                                     CriticHead
Î¼_i = tanh(W_i Ã— Z_t)                        V(s_t) = Dense(32,ReLU) â†’ scalar
Ïƒ_i = softplus(W'_i Ã— Z_t)
a_i = Î¼_i + Ïƒ_i Ã— Îµ,  Îµ~N(0,1)
a_i = clip(a_i, PLC_BOUNDS[name])
```

**Action space (PLC-safe parameter shifts ONLY):**
```python
PLC_BOUNDS = {
    "delta_kp":        (-0.05, +0.05),   # PID proportional Â±5%
    "delta_ki":        (-0.05, +0.05),   # PID integral Â±5%
    "delta_kd":        (-0.05, +0.05),   # PID derivative Â±5%
    "delta_threshold": (-0.10, +0.10),   # Threshold Â±10%
    "delta_schedule":  (-0.20, +0.20),   # Schedule shift Â±20%
    "delta_energy_w":  (-0.15, +0.15),   # Energy routing Â±15%
}
```

**Reward function:**
```
R = Î± Ã— stability_score   (Î±=0.40)   = 1/(1+variance)
  + Î² Ã— efficiency_score  (Î²=0.30)   = 1 âˆ’ energy_waste
  âˆ’ Î³ Ã— actuator_cycles   (Î³=0.15)
  âˆ’ Î´ Ã— boundary_violation (Î´=0.10)
  âˆ’ Îµ Ã— oscillation        (Îµ=0.05)  = |d(output)/dt|
```

**Constrained update (Lagrangian):**
```
L_total = L_policy + câ‚Ã—L_value âˆ’ câ‚‚Ã—Entropy + Î£ Î»áµ¢Ã—ConstraintViolation_i

Î»áµ¢_{t+1} = max(0, Î»áµ¢_t + Î·_Î» Ã— (E[Cáµ¢] âˆ’ d))
```
Î» rises when constraints violated â†’ policy learns to avoid them.

**Action shielding:** Every action passes through `RuleConstraintEngine` before application. If blocked â†’ zero-action (no parameter change) is used instead. Shield rate tracked in stats.

```python
ac = IndustrialActorCritic(state_dim=32)
action, info = ac.select_action(state_vector, shield=rule_engine)
# action = {"delta_kp": 0.021, "delta_ki": -0.008, ...}
# info   = {"shielded": False, "step": 142}
```

**REST API:**
```bash
curl -X POST http://localhost:11436/ciec-rl/act \
  -d '{"state":[0.1,0.2,...32 floats...],"shield":true}'
curl -X POST http://localhost:11436/ciec-rl/observe \
  -d '{"state":[...],"action":[...],"reward":0.8,"cost":0.0}'
curl -X POST http://localhost:11436/ciec-rl/update -d '{"batch_size":64}'
curl http://localhost:11436/ciec-rl/stats
```

---

## ğŸ”— CIEC Full Cycle â€” End-to-End Pipeline

```
1. Parse PLC logic
   POST /plc/parse  â†’  PID params, interlock graph, watchdog timers
   Extracted PID configs stored in Knowledge Graph via /kg/add-pid

2. Observe plant in real-time
   POST /scada/push  â†’  tag readings every 50â€“200ms
   GET  /scada/state â†’  S(t) = plant state vector (input to RL)

3. Check safety before any action
   POST /constraints/validate  â†’  allowed? penalty? clamped action?
   POST /constraints/check-state â†’ is current state safe?

4. RL selects bounded parameter shift
   POST /ciec-rl/act  â†’  delta_kp=+0.02, delta_ki=-0.01, ...
   (automatically shielded through constraint engine)

5. Validate mutation in digital twin BEFORE deploying
   POST /ciec-twin/evaluate  â†’  promoted? survival_score? fault_survival?

6. If promoted â†’ apply to PLC parameter space via OPC UA

7. Record outcome in Knowledge Graph
   POST /kg/add-pid  (if promoted)
   â†’ failure signature if rejected

8. Sync knowledge to other sites
   GET  /kg/export-bundle â†’ signed diff bundle
   POST /kg/import-bundle (at remote site) â†’ cross-site learning

9. Feed transition to RL buffer and train
   POST /ciec-rl/observe  â†’  reward computed from stability+efficiency
   POST /ciec-rl/update   â†’  Lagrangian actor-critic gradient step
```

---

## ğŸ“¡ Complete REST API Reference (59 Endpoints)

### v2.1 â€” Sentinel Intelligence (5 endpoints)
```
POST /sentinel/extract          Trigger autonomous knowledge extraction
POST /sentinel/debate           Swarm Debate for conflicting sources
GET  /sentinel/search           Search swarm knowledge memory
GET  /sentinel/status           Engine health + statistics
GET  /health                    Service ping
```

### v2.2 â€” Advanced Intelligence Modules (12 endpoints)
```
POST /firewall/scan             Adversarial content scan
GET  /decay/scan                Knowledge decay scan
GET  /decay/record/<hash_id>    Single entry confidence
POST /decay/revalidate          Reset after revalidation
GET  /ledger/status             Merkle root + entry count
GET  /ledger/verify             Full tamper detection
GET  /ledger/proof/<hash_id>    Merkle inclusion proof
POST /conflict/analyze          Contradiction cluster analysis
POST /conflict/quick            Two-text cosine similarity check
GET  /tracker/leaderboard       Model ELO + reliability ranking
GET  /tracker/model/<n>         Per-model statistics
POST /tracker/validate          Post-hoc validation
POST /guard/assess              Retrieval trust assessment
```

### v3.0 â€” Industrial AI (13 endpoints)
```
POST /fuzzy/classify            Classify input using fuzzy sets
POST /fuzzy/update              Update fuzzy output with feedback
POST /fuzzy/tune                Trigger auto-tuning step (gradient/evolutionary)
GET  /fuzzy/stats               Membership function parameters

POST /rl/act                    Get RL action (CMDP with safety layer)
POST /rl/learn                  Constrained policy + value update
GET  /rl/stats                  RL training statistics

POST /twin/evaluate             Evaluate mutation candidate (Monte Carlo EVT)
GET  /twin/stats                Twin simulation statistics

POST /mesh/register             Register node in federated mesh
POST /mesh/share                Share parameter delta (Byzantine-protected)
GET  /mesh/leaderboard          Trust-weighted node ranking
GET  /mesh/stats                Global mesh statistics
```

### v4.0 â€” CIEC Cognitive Industrial Core (28 endpoints) ğŸ†•
```
POST /plc/parse                 Parse IEC 61131-3 ST â†’ CIR + DSG
GET  /plc/stats                 Parser cache statistics

POST /scada/push                Ingest real-time OPC tag readings
POST /scada/ingest-history      Batch ingest SQL historian records
GET  /scada/state               Current plant state vector S(t)
GET  /scada/anomalies           Tags with anomalous z-scores
GET  /scada/stats               Observer statistics

POST /ciec-twin/run             Run physics simulation episode
POST /ciec-twin/evaluate        Evaluate mutation candidate
GET  /ciec-twin/stats           Twin run statistics

POST /constraints/validate      Validate action against all constraints
POST /constraints/check-state   Quick hard-constraint state check
GET  /constraints/list          All registered constraints
GET  /constraints/violations    Recent violation audit log
GET  /constraints/stats         Block rate + violation categories

POST /kg/add-pid                Store proven PID configuration
POST /kg/add-failure            Record failure signature + fix template
POST /kg/find-similar           Vector similarity search
POST /kg/find-by-symptoms       Match failure signatures to symptoms
GET  /kg/recurring-patterns     Cross-project recurring problem detection
GET  /kg/export-bundle          Signed knowledge diff for federated sync
POST /kg/import-bundle          Import verified knowledge from remote site
GET  /kg/nodes                  List knowledge graph nodes
GET  /kg/stats                  Graph statistics

POST /ciec-rl/act               Constrained bounded parameter-shift action
POST /ciec-rl/observe           Feed transition to replay buffer
POST /ciec-rl/update            Lagrangian actor-critic gradient update
GET  /ciec-rl/stats             RL statistics + PLC bounds
```

---

## ğŸ“¦ Complete Repository Structure

```
KISWARM/
â”‚
â”œâ”€â”€ ğŸ“ deploy/
â”‚   â””â”€â”€ kiswarm_deploy.sh           # 10-phase automated deployment
â”‚
â”œâ”€â”€ ğŸ“ scripts/
â”‚   â”œâ”€â”€ start_all_services.sh       # Master service orchestrator
â”‚   â”œâ”€â”€ sentinel_trigger.sh         # Sentinel CLI + CKM integration
â”‚   â”œâ”€â”€ cleanup_old_backups.sh      # 30-day backup rotation
â”‚   â”œâ”€â”€ health_check.sh             # 40+ diagnostic checks
â”‚   â”œâ”€â”€ system_navigation.sh        # sys-nav central hub
â”‚   â””â”€â”€ setup_cron.sh               # One-click cron automation
â”‚
â”œâ”€â”€ ğŸ“ python/
â”‚   â”œâ”€â”€ kiswarm_status.py           # Real-time Rich monitoring dashboard
â”‚   â”œâ”€â”€ tool_proxy.py               # Tool injection proxy (Flask, :11435)
â”‚   â””â”€â”€ sentinel/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”‚
â”‚       â”‚  â”€â”€ v2.1 SENTINEL BRIDGE â”€â”€
â”‚       â”œâ”€â”€ sentinel_bridge.py      # AKE engine: 4 scouts + injector
â”‚       â”œâ”€â”€ swarm_debate.py         # Multi-model conflict resolution
â”‚       â”‚
â”‚       â”‚  â”€â”€ v2.2 INTELLIGENCE MODULES â”€â”€
â”‚       â”œâ”€â”€ semantic_conflict.py    # Cosine similarity contradiction clustering
â”‚       â”œâ”€â”€ knowledge_decay.py      # Half-life decay engine (6 categories)
â”‚       â”œâ”€â”€ model_tracker.py        # ELO + reliability tracker
â”‚       â”œâ”€â”€ crypto_ledger.py        # SHA-256 Merkle ledger
â”‚       â”œâ”€â”€ retrieval_guard.py      # 4-layer retrieval trust assessment
â”‚       â”œâ”€â”€ prompt_firewall.py      # Adversarial content firewall
â”‚       â”‚
â”‚       â”‚  â”€â”€ v3.0 INDUSTRIAL AI â”€â”€
â”‚       â”œâ”€â”€ fuzzy_tuner.py          # Gaussian/Bell fuzzy + Lyapunov gate
â”‚       â”œâ”€â”€ constrained_rl.py       # CMDP: masking + Lagrangian + Shielded
â”‚       â”œâ”€â”€ digital_twin.py         # Monte Carlo mutation + EVT tail test
â”‚       â”œâ”€â”€ federated_mesh.py       # Multi-Krum Byzantine mesh
â”‚       â”‚
â”‚       â”‚  â”€â”€ v4.0 CIEC CORE â”€â”€
â”‚       â”œâ”€â”€ plc_parser.py           # IEC 61131-3 ST â†’ CIR + DSG (493L)
â”‚       â”œâ”€â”€ scada_observer.py       # OPC/SQL observer + 12-feature extraction (587L)
â”‚       â”œâ”€â”€ physics_twin.py         # Thermal+Pump+Battery+Power physics (693L)
â”‚       â”œâ”€â”€ rule_engine.py          # Absolute constraint safety layer (485L)
â”‚       â”œâ”€â”€ knowledge_graph.py      # Cross-project KG + federated sync (587L)
â”‚       â”œâ”€â”€ actor_critic.py         # Constrained Actor-Critic RL (693L)
â”‚       â”‚
â”‚       â””â”€â”€ sentinel_api.py         # Flask REST API â€” ALL 59 endpoints
â”‚
â”œâ”€â”€ ğŸ“ tests/
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ test_tool_proxy.py          # 50 tests
â”‚   â”œâ”€â”€ test_kiswarm_status.py      # 19 tests
â”‚   â”œâ”€â”€ test_sentinel.py            # 37 tests â€” v2.1 AKE
â”‚   â”œâ”€â”€ test_advanced_modules.py    # 99 tests â€” v2.2 (Modules 1-6)
â”‚   â”œâ”€â”€ test_v3_modules.py          # 105 tests â€” v3.0 (Modules 7-10)
â”‚   â””â”€â”€ test_ciec_modules.py        # 120 tests â€” v4.0 (Modules 11-16) ğŸ†•
â”‚
â”œâ”€â”€ ğŸ“ config/
â”‚   â”œâ”€â”€ governance_config.json
â”‚   â””â”€â”€ kiswarm.service
â”‚
â”œâ”€â”€ .github/workflows/ci.yml
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ requirements-dev.txt
â””â”€â”€ README.md
```

---

## ğŸ§ª Test Coverage â€” 948 Tests, All Passing

```
tests/test_v43_security.py       85 tests  â† v4.3 ICS Cybersecurity (Modules 29-30) ğŸ†•
tests/test_v42_modules.py       157 tests  â† v4.2 XAI/PdM/SIL/Thread (Modules 24-28)
tests/test_v41_modules.py       142 tests  â† v4.1 TD3/AST/VMware/Formal (Modules 17-23)
tests/test_ciec_modules.py      120 tests  â† v4.0 CIEC (Modules 11-16)
tests/test_v3_modules.py        105 tests  â† v3.0 (Modules 7-10)
tests/test_advanced_modules.py   99 tests  â† v2.2 (Modules 1-6)
tests/test_sentinel.py           37 tests  â† v2.1 AKE engine
tests/test_tool_proxy.py         50 tests
tests/test_kiswarm_status.py     19 tests
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL                            948 tests  âœ… ALL PASSING
```

```bash
# Run full suite
pip install -r requirements-dev.txt
pytest tests/ --ignore=tests/test_deploy.py -v

# Run only CIEC tests
pytest tests/test_ciec_modules.py -v

# Run integration tests
pytest tests/test_ciec_modules.py::TestCIECPipeline -v
```

---

## ğŸ”’ Security & Privacy

| Property | Status |
|---|---|
| Data leaves the machine | âŒ Never â€” 100% local |
| Cloud APIs after setup | âŒ None required |
| AI directly binds RS-485 | âŒ Never â€” OPC UA intermediate API only |
| Runs as root | âŒ Never â€” regular user only |
| PLC parameters mutated directly | âŒ Always via OPC UA bounded write |
| Raw actuator commands from AI | âŒ Parameter shifts only (Â±5% max) |
| Audit logging | âœ… All operations recorded |
| Cryptographic knowledge signing | âœ… SHA-256 + Merkle tree |
| Adversarial content firewall | âœ… 3-layer pattern + statistical |
| Constraint engine override | âœ… Hard constraints cannot be bypassed |

---

## âš™ï¸ System Requirements

| Component | Minimum | Recommended |
|---|---|---|
| OS | Ubuntu 20.04+ / Debian 12+ | Ubuntu 22.04 LTS |
| RAM | 8 GB | 16 GB+ |
| Disk | 20 GB free | 50 GB+ SSD |
| Python | 3.8+ | 3.11+ |
| GPU | Optional | NVIDIA CUDA (2Ã— speed) |
| Network (after setup) | Not required | Air-gapped OK |

---

## ğŸ”§ Version History

### v4.0 â€” 2026-02-27 *(Current)*
- âœ… **Module 11: PLC Semantic Parser** â€” IEC 61131-3 tokenizer, CIR/DSG builder, PID/interlock/watchdog detection
- âœ… **Module 12: SCADA/OPC/SQL Observer** â€” 12-feature time-series extraction, PlantStateVector builder
- âœ… **Module 13: Digital Twin Physics Engine** â€” Thermal/Pump/Battery/Power physics, fault injection, mutation evaluation
- âœ… **Module 14: Rule Constraint Engine** â€” Hard+soft constraints, Lagrangian shielding, < 100Î¼s validation
- âœ… **Module 15: Cross-Project Knowledge Graph** â€” PID configs, failure signatures, cosine+Jaccard similarity, federated sync
- âœ… **Module 16: Industrial Actor-Critic RL** â€” Constrained bounded parameter shifts, Lagrangian multipliers, action shielding
- âœ… **59 REST API endpoints** â€” 28 new CIEC endpoints
- âœ… **430 tests passing** â€” 120 new CIEC tests

### v3.0 â€” 2026-02-26
- âœ… Module 7: Fuzzy Membership Auto-Tuner (Lyapunov stability gate)
- âœ… Module 8: Constrained RL Engine (CMDP, Lagrangian, Shielded RL)
- âœ… Module 9: Digital Twin Mutation Pipeline (Monte Carlo, EVT tail test)
- âœ… Module 10: Federated Adaptive Mesh (Multi-Krum Byzantine tolerance)
- âœ… 29 REST endpoints | 310 tests

### v2.2-EMS â€” 2026-02-25
- âœ… Modules 1â€“6: Semantic Conflict Â· Decay Â· Tracker Â· Ledger Â· Guard Â· Firewall
- âœ… 17 REST endpoints | 205 tests

### v2.1-EMS â€” 2026-02-25
- âœ… Sentinel Bridge: AKE + 4 Scouts + Swarm Debate
- âœ… 5 REST endpoints | 148 tests

### v1.1 â€” 2026-02-22
- âœ… Portable $HOME paths, trap handlers, Qdrant VectorParams, backup rotation
- âœ… 111 tests

### v1.0 â€” 2026-02-22
- âœ… Initial production release, 10-phase deployment

---

## ğŸ“„ License

MIT License â€” Free to use, modify, and distribute globally.

---

## ğŸŒŸ Credits

**Architect:** Baron Marco Paolo Ialongo  
**Version:** 4.3 (CIEC + Industrial Cybersecurity)  
**Repository:** https://github.com/Baronki2/KISWARM  
**Tests:** 864 passing | **Endpoints:** 148 | **Modules:** 30

*"The Swarm sees all. The Swarm knows all. The Swarm evolves eternally."* ğŸŒŒ

---
---


---

---

# ğŸ†• KISWARM v4.1 â€” TD3 Â· AST Â· Extended Physics Â· VMware Â· Formal Â· Byzantine Â· Governance

> **7 new modules | 99 endpoints | 572 tests**

## Layered Architecture (L0â€“L7)

```
L7  Federated Cognitive Mesh       Module 22 â€” Byzantine-tolerant (Nâ‰¥3f+1)
L6  Mutation Governance + Formal   Module 23 + 21 â€” 11-step pipeline, Lyapunov
L5  Learning Core                  Module 17 â€” TD3 twin critics, policy delay=2
L4  Digital Twin Simulation        Module 19 â€” RK4 ThermalÂ·PumpÂ·ValveÂ·MotorÂ·Battery
L3  PLC Semantic Extraction        Module 18 â€” Full IEC 61131-3 CFG/DDG/SDG
L2  Data Acquisition               Module 11 â€” SCADA/OPC monitoring
L1  Virtualization Orchestrator    Module 20 â€” VMware snapshot/clone/rollback
L0  Physical PLC / Field Layer     NEVER modified autonomously â€” hard-key locked
```

## v4.1 New Modules (7)

| # | Module | Description |
|---|--------|-------------|
| 17 | TD3 Industrial Controller | Actor-Critic RL: 8-action PLC tuning, twin critics, Î³=0.995 |
| 18 | IEC 61131-3 AST Parser | Recursive-descent ST parser + CFG/DDG/SDG + pattern detection |
| 19 | Extended Physics Twin | RK4 multi-block plant: ThermalÂ·PumpÂ·ValveÂ·MotorÂ·BatteryÂ·Electrical |
| 20 | VMware Orchestrator | Snapshot/clone/rollback lifecycle with immutable audit log |
| 21 | Formal Verification | Lyapunov stability (Stein eq.) + sampling barrier certificates |
| 22 | Byzantine Aggregator | Trimmed-mean/Krum/Median/FLTrust â€” Nâ‰¥3f+1 condition enforced |
| 23 | Mutation Governance | 11-step pipeline, no step skippable, human gate at Step 8 |

## Mutation Governance Pipeline (11 Steps â€” No Shortcuts)

```
Step  1  Extract semantic block from PLC (AST parser)
Step  2  Propose mutation (TD3 RL policy)
Step  3  Validate parameter bounds (Î”Kp âˆˆ [âˆ’5%,+5%] etc.)
Step  4  Digital twin simulation (5 Monte Carlo episodes)
Step  5  Fault injection sweep (4 operating conditions)
Step  6  Formal stability verification (Lyapunov + barrier)
Step  7  Generate signed audit report
Step  8  â›” HUMAN APPROVAL GATE â€” Baron Marco Paolo Ialongo ONLY
         Authorization code: Maquister_Equtitum
Step  9  Deploy to test PLC (VM-C clone, network-isolated)
Step 10  Full system acceptance test (20 test cases)
Step 11  Production key release (PRODKEY_<SHA256[:16]>)
```

**Rejection is automatic at Steps 3â€“6 if conditions not met.**
**No human can skip the formal verification or twin simulation.**

## TD3 Hyperparameters

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| Discount Î³ | 0.995 | Long-horizon industrial control |
| Soft-update Ï„ | 0.002 | Conservative target tracking |
| Policy noise Ïƒ | 0.1 | Target policy smoothing |
| Noise clip | 0.2 | Anti-adversarial Q |
| Actor LR | 1Ã—10â»â´ | Conservative updates |
| Critic LR | 5Ã—10â»â´ | Faster convergence |
| Batch size | 512 | Industrial-scale replay |
| Replay buffer | 2,000,000 | Rare event memory |
| Policy delay | 2 | TD3 double-Q trick |

**Reward:** `R = 0.40Â·stability + 0.30Â·efficiency âˆ’ 0.15Â·cycles âˆ’ 0.10Â·violation âˆ’ 0.05Â·oscillation`

## Formal Verification

**Lyapunov (Method A â€” Linearized):**
```
Solve:   Aáµ€PA âˆ’ P = âˆ’Q   (discrete-time Stein equation)
Approve: Ï(A) < 1  AND  P is positive definite
```

**Barrier Certificate (Method B â€” Nonlinear):**
```
Sample 500 points in safe set S
Check:  B(x) â‰¥ 0  AND  dB/dt â‰¤ 0  at every point
Approve only if: zero violations
```

## Byzantine Federated Aggregation

```
Condition:  N â‰¥ 3f + 1  (N sites, f Byzantine tolerated)
Methods:    trimmed_mean | krum | median | fltrust
Update:     Î¸ â† Î¸ âˆ’ Î· Â· robust_mean(gáµ¢)
Privacy:    No raw plant data leaves any site â€” gradients only
```

## VMware Safety Rules (Hard-Coded)

1. **VM-A, VM-B** (production) â†’ AI may only READ, never mutate
2. All mutations run on **network-isolated CLONES** of test VMs
3. Every operation â†’ **immutable SHA-256 audit entry**
4. Promotion requires `Maquister_Equtitum` authorization code
5. No direct ESXi root access from AI layer


---

---

# ğŸ†• KISWARM v4.2 â€” XAI Â· Predictive Maintenance Â· Multi-Agent Â· SIL Â· Digital Thread

> **5 new modules | 133 endpoints | 729 tests**

## v4.2 New Modules (5)

| # | Module | File | Description |
|---|--------|------|-------------|
| 24 | Explainability Engine | `explainability_engine.py` | KernelSHAP attribution for every AI decision |
| 25 | Predictive Maintenance | `predictive_maintenance.py` | LSTM RUL prediction + degradation curves + fleet management |
| 26 | Multi-Agent Coordinator | `multiagent_coordinator.py` | NÃ—TD3 agents with 3-phase consensus + conflict resolution |
| 27 | SIL Verification Engine | `sil_verification.py` | IEC 61508 PFD/SIL/HFT/SFF + mutation impact |
| 28 | Digital Thread Tracker | `digital_thread.py` | End-to-end traceability DAG + IEC 62443 compliance |

## Module 24 â€” Explainability Engine (XAI)

**KernelSHAP** (pure Python, no external ML libs):
- Samples 2â¿ coalitions (or n_samples for large n)
- SHAP kernel weighting: `w = (n-1) / (C(n,s) Â· s Â· (n-s))`
- Weighted least-squares via Gauss elimination + regularisation
- Counterfactual "what-if": Â±10% per top-3 feature
- Immutable SHA-256 chained `ExplanationLedger`

Explains: TD3 actions Â· Lyapunov verdicts Â· Governance pipeline steps Â· Physics twin outputs

## Module 25 â€” Predictive Maintenance Engine (PdM)

**Asset classes:** pump Â· motor Â· valve Â· bearing Â· electrical Â· compressor Â· heat_exchanger

**Degradation models:**

| Model | Formula | Best for |
|-------|---------|----------|
| Linear | HI = 1 âˆ’ kÂ·t | Valves, simple wear |
| Exponential | HI = exp(âˆ’Î±t) | Motors, electrical |
| Sigmoid | HI = 1/(1+exp(kÂ·(tâˆ’0.7))) | Pumps â€” holds then drops |

**Alarm levels:** healthy (0.6â€“1.0) Â· warning (0.3â€“0.6) Â· critical (0.1â€“0.3) Â· failed (0.0â€“0.1)

**RUL Monte Carlo** â€” 100 samples, Ïƒ = max(0.02, (1-HI)Â·0.1) â†’ 10th/90th percentile CI

## Module 26 â€” Multi-Agent Plant Coordinator

N independent `SectionAgent` actors with 3-phase consensus protocol:
1. Each agent proposes action + resource demand independently
2. `CoordinatorBus` pub/sub broadcast
3. `ConflictResolver` â€” priorityÃ—Q-value arbitration, proportional scaling

**Shared resource limits:** 500 kW total power Â· 80 mÂ³/h cooling Â· 8 bar compressed air

**Reward:** `R_shaped = R_local âˆ’ 0.5Â·conflict_penalty + 0.2Â·coord_bonus`

## Module 27 â€” IEC 61508 SIL Verification Engine

**Architectures:** 1oo1 Â· 1oo2 Â· 2oo2 Â· 2oo3 Â· 1oo3 Â· 2oo4

| SIL | PFD Range | Risk Reduction |
|-----|-----------|----------------|
| 1 | 10â»Â² â€“ 10â»Â¹ | 10â€“100Ã— |
| 2 | 10â»Â³ â€“ 10â»Â² | 100â€“1,000Ã— |
| 3 | 10â»â´ â€“ 10â»Â³ | 1,000â€“10,000Ã— |
| 4 | 10â»âµ â€“ 10â»â´ | 10,000â€“100,000Ã— |

Mutation impact: `Î»_d_new = Î»_d Ã— (1 + Î£|deltas| Ã— 0.5)` â€” auto-reject if SIL degrades.

## Module 28 â€” Digital Thread Tracker

**14 node types Â· 9 edge types Â· BFS lineage queries**

Compliance standards built-in: IEC 61508 Â· IEC 62443 Â· NAMUR NE 175


---

---

# ğŸ†• KISWARM v4.3 â€” ICS Cybersecurity Engine (IEC 62443 + MITRE ATT&CK for ICS)

> **2 new modules | 148 endpoints | 948 tests**  
> *Fully autonomous, defensive-only. Observe, detect, and report â€” never control, never attack.*

## Security Design Principle

```
AI NEVER sends write commands to PLCs or actuators.
Security agents are read-only, passive, and defensive.
All findings are signed and stored in tamper-proof ledger.
No tool in KISWARM generates exploits or attacks systems.
```

## v4.3 New Modules (2)

| # | Module | File | Description |
|---|--------|------|-------------|
| 29 | ICS Cybersecurity Engine | `ics_security.py` | IEC 62443 SL assessment + 5 defensive agents + MITRE ATT&CK mapping |
| 30 | OT Network Monitor | `ot_network_monitor.py` | Passive OT protocol anomaly detection (Modbus/OPC-UA/PROFINET/DNP3) |

---

## Module 29 â€” ICS Cybersecurity Engine (`ics_security.py`)

**5 Defensive Security Agents (all read-only):**

| Agent | Function |
|-------|----------|
| **CVE Intelligence Agent** | Matches observed software/firmware versions to industrial CVE database (Modbus, OPC-UA, PROFINET, EtherNet/IP, HART, DNP3) |
| **Network Anomaly Detector** | Statistical baseline on OT protocol traffic; z-score alerts on unusual command frequencies |
| **PLC Code Security Scanner** | Static analysis of Structured Text for 12 unsafe patterns: unvalidated inputs, unsafe type casts, missing watchdog, buffer overflows |
| **SCADA Config Assessor** | Checks encryption status, auth strength, patch level, default credentials, unnecessary services |
| **Incident Correlation Engine** | MITRE ATT&CK for ICS mapping; correlates alerts across all agents into unified incidents |

**IEC 62443 Security Levels:**

| SL | Description | Controls Required |
|----|-------------|------------------|
| SL 0 | No security requirement | Not assessed |
| SL 1 | Protection against casual/coincidental violation | Single-factor auth, basic logging |
| SL 2 | Protection against intentional attack with simple means | Network segmentation, encrypted comms |
| SL 3 | Protection against sophisticated/motivated attacker | MFA, anomaly detection, signed firmware |
| SL 4 | Protection against state-sponsored attack | HSM, formal verification, air-gap |

**MITRE ATT&CK for ICS â€” Tactic Detection Coverage:**

| Tactic | Example Techniques Detected |
|--------|----------------------------|
| Initial Access | Spearphishing, Exploit Public-Facing Application |
| Execution | Command-Line Interface, Native API abuse |
| Persistence | Valid Accounts, External Remote Services |
| Lateral Movement | Default Credentials, Remote Services |
| Collection | Automated Collection, Data from Local System |
| Inhibit Response | Alarm Suppression, Activate Firmware Update Mode |
| Impair Process Control | Unauthorized Command Message, Block Reporting |
| Impact | Loss of Availability, Safety System Manipulation |

**SHA-256 chained Security Incident Ledger** â€” every finding tamper-proof.

```bash
# Scan PLC code for security vulnerabilities (static, read-only)
curl -X POST http://localhost:11436/security/scan-plc \
  -d '{"source":"PROGRAM PumpCtrl\n...\nEND_PROGRAM","program_name":"PumpCtrl"}'
# â†’ {"findings":[{"severity":"HIGH","pattern":"missing_watchdog","recommendation":"..."}]}

# Push network event metadata for anomaly analysis
curl -X POST http://localhost:11436/security/network-event \
  -d '{"protocol":"modbus","function_code":6,"src_ip":"192.168.1.50","rate_hz":12.0}'
# â†’ {"anomaly":true,"z_score":4.2,"tactic":"Impair Process Control"}

# Get current IEC 62443 security posture
curl http://localhost:11436/security/posture
# â†’ {"sl_achieved":2,"sl_target":3,"gap_findings":["MFA not configured","..."]}

# Full IEC 62443 assessment for an asset
curl -X POST http://localhost:11436/security/iec62443-assess \
  -d '{"asset_id":"reactor_plc","target_sl":3}'

# Check active incidents mapped to MITRE ATT&CK
curl http://localhost:11436/security/incidents?limit=20
```

---

## Module 30 â€” OT Network Monitor (`ot_network_monitor.py`)

**Passive industrial protocol traffic analysis** â€” no packets injected.

**Supported protocols:** Modbus TCP Â· OPC-UA Â· PROFINET Â· EtherNet/IP Â· DNP3 Â· HART-IP Â· IEC 61850 MMS

**Baseline engine:**
- Rolling 24h window per protocolÃ—command pair
- Exponential moving average (Î±=0.1) + 3Ïƒ anomaly threshold
- Automatic re-baselining after registered maintenance windows

**Alert conditions detected:**
- Command frequency anomaly (unusual Modbus write rate)
- New source IP communicating with PLC first time
- Unusual function codes (Modbus FC 8/43 = diagnostic/encapsulate)
- Large payload to field device (potential unauthorized firmware push)
- Engineering station active outside permitted hours

```bash
# Register OT network segment for monitoring
curl -X POST http://localhost:11436/ot-monitor/segment \
  -d '{"segment_id":"reactor_field","subnet":"10.10.1.0/24","protocols":["modbus","opc_ua"]}'

# Ingest packet metadata (NOT payload â€” privacy preserved)
curl -X POST http://localhost:11436/ot-monitor/packet \
  -d '{"segment_id":"reactor_field","protocol":"modbus","function_code":6,"src":"10.10.1.20","dst":"10.10.1.5","payload_bytes":8}'

# Get active anomaly alerts
curl http://localhost:11436/ot-monitor/alerts

# View statistical baseline
curl http://localhost:11436/ot-monitor/baseline/reactor_field
```

---

## IEC 62443 Zone Model â€” Security Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ZONE 4 â€” Enterprise Network (IT)                        â”‚
â”‚  KISWARM AI Â· Qdrant Â· Ollama Â· REST API :11436         â”‚
â”‚  ICS Security Engine reads alerts from all zones         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ DMZ / Conduit (monitored by Module 30)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ZONE 3 â€” Operations Network (OT)                        â”‚
â”‚  SCADA Servers Â· Historian Â· HMI                         â”‚
â”‚  â† OT Network Monitor watches passively here            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ Secure conduit (OPC UA / TLS)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ZONE 2 â€” Control Network (OT)                           â”‚
â”‚  DCS Â· Safety PLC Â· Engineering Stations                 â”‚
â”‚  â† PLC Code Scanner analyzes logic (read-only)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ Fieldbus (Modbus/PROFINET)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ZONE 1 â€” Field Level (OT)                               â”‚
â”‚  PLCs Â· RTUs Â· Smart Instruments Â· Actuators             â”‚
â”‚  â›” AI NEVER WRITES TO THIS ZONE                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## About HexStrike Integration

The KISWARM v4.3 security layer incorporates the **defensive concepts** from HexStrike AI MCP (CVE Intelligence, Network Scout, Vulnerability Correlator, Rate Limit Detector, Failure Recovery) fully integrated with the CIEC framework:

- **CVE Intelligence** feeds the ICS CVE database â†’ CIEC Knowledge Graph
- **Network Scout** drives the OT Network Monitor passive baseline
- **Vulnerability Correlator** powers the Incident Correlation Engine
- **Rate Limit Detector** is the anomaly z-score engine in Module 30
- **Failure Recovery** drives automated response playbooks (alert + suggest, never act)

All agents access PLC parser data, SCADA observations, physics twin, and constraint engine â€” making every security finding context-aware and validated against plant physics before alerting.

> **Note:** Exploit generation and active attack tooling are NOT implemented. For industrial infrastructure, all security actions are observe-only. Generating real exploits targeting operating PLCs/SCADA violates IEC 62443 and creates physical safety risk.


---

# PRESERVED: Previous Version Documentation

> The sections below preserve the complete documentation from v1.1 through v3.0.
> All original descriptions, algorithms, and API references remain intact.

---

 â€” Autonomous AI Swarm Governance Platform

> **ETERNAL SWARM EVOLUTION SYSTEM** â€” Enterprise Military Standard Edition  
> *Production-Hardened Â· Self-Healing Â· Sentinel-Class Intelligence Â· 310 Tests Passing*  
> **Architect:** Baron Marco Paolo Ialongo

[![Version](https://img.shields.io/badge/version-3.0--EMS-blue.svg)](https://github.com/Baronki2/KISWARM)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![CI](https://github.com/Baronki2/KISWARM/actions/workflows/ci.yml/badge.svg)](https://github.com/Baronki2/KISWARM/actions/workflows/ci.yml)
[![Tests](https://img.shields.io/badge/tests-310%20passing-success.svg)](tests/)
[![Status](https://img.shields.io/badge/status-Production%20Ready-brightgreen.svg)](README.md)
[![Ollama](https://img.shields.io/badge/powered%20by-Ollama-orange.svg)](https://ollama.com)

---

## ğŸ¯ What is KISWARM?

KISWARM is a complete, self-managing AI governance platform that orchestrates 27+ local LLM models via Ollama with **persistent vector memory**, **autonomous knowledge extraction**, **real-time monitoring**, and **self-healing capabilities** â€” running 100% locally, zero cloud dependency.

Version **2.1-EMS** introduces the **Sentinel Bridge**: an Autonomous Knowledge Extraction (AKE) engine that detects knowledge gaps in the swarm, deploys multi-source research scouts in parallel, cross-verifies intelligence via a **Swarm Debate** between local models, and injects distilled knowledge directly into the Qdrant vector database â€” without any human intervention.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            KISWARM v2.1-EMS PRODUCTION SYSTEM                   â”‚
â”‚            ETERNAL SWARM EVOLUTION SYSTEM                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                    â–¼                    â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ Ollama â”‚         â”‚  Qdrant  â”‚         â”‚  Tool    â”‚
     â”‚ :11434 â”‚         â”‚  Memory  â”‚         â”‚  Proxy   â”‚
     â”‚ 27+    â”‚         â”‚    DB    â”‚         â”‚  :11435  â”‚
     â”‚ Models â”‚         â”‚  Vector  â”‚         â”‚  Flask   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                    â”‚                    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                               â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ SENTINEL BRIDGE â”‚           â”‚  Swarm Debate    â”‚
     â”‚    Port 11436   â”‚           â”‚    Engine        â”‚
     â”‚                 â”‚           â”‚                  â”‚
     â”‚ â€¢ WikipediaScoutâ”‚           â”‚ â€¢ Multi-model    â”‚
     â”‚ â€¢ ArxivScout    â”‚           â”‚   voting         â”‚
     â”‚ â€¢ DuckDuckGo    â”‚           â”‚ â€¢ Conflict res.  â”‚
     â”‚ â€¢ OllamaScout   â”‚           â”‚ â€¢ Synthesis gen  â”‚
     â”‚ â€¢ CKM Gap Det.  â”‚           â”‚                  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                               â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚      Monitoring & Ops         â”‚
              â”‚                               â”‚
              â”‚  â€¢ kiswarm-status (Rich UI)   â”‚
              â”‚  â€¢ kiswarm-health (40+ checks)â”‚
              â”‚  â€¢ Systemd auto-restart       â”‚
              â”‚  â€¢ Daily backup rotation      â”‚
              â”‚  â€¢ 30-min health cron         â”‚
              â”‚  â€¢ Full audit logging         â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ Quick Start â€” 3 Commands

```bash
# 1. Clone the repository
git clone https://github.com/Baronki2/KISWARM.git && cd KISWARM

# 2. Run the 10-phase automated deployment (15-20 minutes)
chmod +x deploy/kiswarm_deploy.sh && ./deploy/kiswarm_deploy.sh

# 3. Activate and verify
source ~/.bashrc && kiswarm-health && sys-nav
```

**System is fully operational when you see:** `Overall Health: 90%+` âœ…

---

## âœ¨ Feature Matrix â€” v1.1 vs v2.1-EMS

| Feature | v1.1 | v2.1-EMS | v2.2-EMS | v3.0 |
|---|:---:|:---:|:---:|:---:|
| ğŸ§  Persistent Vector Memory (Qdrant) | âœ… | âœ… + Sentinel KB | âœ… | âœ… |
| ğŸ”§ Auto Tool Injection (Port 11435) | âœ… | âœ… | âœ… | âœ… |
| ğŸ“Š Real-Time Monitoring Dashboard | âœ… | âœ… | âœ… | âœ… |
| ğŸ›¡ï¸ Self-Healing (Systemd + Trap) | âœ… | âœ… | âœ… | âœ… |
| ğŸ§¹ Automated Maintenance (30-day) | âœ… | âœ… | âœ… | âœ… |
| ğŸ›ï¸ Governance Mode + Audit Logging | âœ… | âœ… | âœ… | âœ… |
| ğŸ¤– 27+ Ollama Models | âœ… | âœ… | âœ… | âœ… |
| ğŸ§ª Test Coverage | 111 | 148 | 205 | **310** |
| ğŸ›°ï¸ Sentinel Bridge (AKE) | âŒ | âœ… | âœ… | âœ… |
| ğŸ”¬ Multi-Source Scouts (4 types) | âŒ | âœ… | âœ… | âœ… |
| âš”ï¸ Swarm Debate Engine | âŒ | âœ… | âœ… | âœ… |
| ğŸŒ Sentinel REST API | âŒ | âœ… (13) | âœ… (17) | âœ… **(29)** |
| ğŸ§² Semantic Conflict Detection | âŒ | âŒ | âœ… | âœ… |
| â³ Knowledge Decay Engine | âŒ | âŒ | âœ… | âœ… |
| ğŸ† Model Performance Tracker (ELO) | âŒ | âŒ | âœ… | âœ… |
| ğŸ” Cryptographic Knowledge Ledger | âŒ | âŒ | âœ… | âœ… |
| ğŸ” Differential Retrieval Guard | âŒ | âŒ | âœ… | âœ… |
| ğŸš« Adversarial Prompt Firewall | âŒ | âŒ | âœ… | âœ… |
| ğŸ›ï¸ **Fuzzy Membership Auto-Tuner** | âŒ | âŒ | âŒ | âœ… **NEW** |
| ğŸ¤– **Constrained RL Engine (CMDP)** | âŒ | âŒ | âŒ | âœ… **NEW** |
| ğŸ”¬ **Digital Twin Mutation Pipeline** | âŒ | âŒ | âŒ | âœ… **NEW** |
| ğŸŒ **Federated Adaptive Mesh (Byzantine)** | âŒ | âŒ | âŒ | âœ… **NEW** |

---

## ğŸ›¡ï¸ SENTINEL BRIDGE â€” Autonomous Knowledge Extraction (AKE)

### The Deep-Extraction Loop

The Sentinel Bridge operates on a 5-phase autonomous pipeline:

```
Phase 1: GAP DETECTION
  Central Knowledge Manager (CKM) queries local Ollama model:
  "Rate your confidence for this query: 0.0â€“1.0"
  
  Confidence â‰¥ 85%  â†’ Swarm answers directly (no extraction needed)
  Confidence  < 85%  â†’ KNOWLEDGE GAP DETECTED â†’ Deploy scouts

Phase 2: PARALLEL SCOUT DEPLOYMENT
  4 scouts launch simultaneously (aiohttp async):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  WikipediaScout  â†’ Wikipedia REST API  (conf: 0.75) â”‚
  â”‚  ArxivScout      â†’ ArXiv Paper API    (conf: 0.85)  â”‚
  â”‚  DuckDuckGoScout â†’ DDG Instant API    (conf: 0.65)  â”‚
  â”‚  OllamaScout     â†’ Local LLM synth.  (conf: 0.70)  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Phase 3: LOGIC SYNTHESIS
  LogicSynthesizer processes all returns:
  â€¢ Deduplication by MD5 content hash
  â€¢ Rank by confidence score descending
  â€¢ Strip HTML/noise, clean whitespace
  â€¢ Detect content disparity conflicts
  â€¢ Compute aggregate confidence (multi-source bonus)

Phase 4: SWARM DEBATE (if conflicts detected)
  All local Ollama models receive both conflicting payloads.
  Each model votes: A  |  B  |  SYNTHESIS + 1-sentence argument
  Tally determines winner. SYNTHESIS â†’ model generates merged truth.

Phase 5: MEMORY INJECTION
  SwarmMemoryInjector vectorizes (384-dim, all-MiniLM-L6-v2)
  and upserts verified SwarmKnowledge into Qdrant collection
  'sentinel_knowledge' with full metadata and audit trail.
```

### Intelligence Packet Structure

```python
@dataclass
class SwarmKnowledge:
    query:          str          # Original query that triggered extraction
    content:        str          # Distilled, verified intelligence payload
    sources:        list         # [{source, url, confidence}, ...]
    confidence:     float        # Aggregate confidence (0.0â€“1.0)
    classification: str          # "SENTINEL-VERIFIED-EMS"
    timestamp:      str          # ISO 8601
    hash_id:        str          # SHA-256 dedup fingerprint (16 chars)
```

### Sentinel REST API (Port 11436)

| Method | Endpoint | Description |
|---|---|---|
| `POST` | `/sentinel/extract` | Trigger AKE for a query |
| `POST` | `/sentinel/debate` | Resolve conflicting intelligence via Swarm Debate |
| `GET` | `/sentinel/search?q=<query>` | Search existing swarm knowledge memory |
| `GET` | `/sentinel/status` | Engine health + extraction statistics |
| `GET` | `/health` | Service ping |

**Extract knowledge â€” example:**
```bash
curl -X POST http://localhost:11436/sentinel/extract \
  -H "Content-Type: application/json" \
  -d '{"query": "quantum key distribution protocols", "threshold": 0.85}'

# Response:
{
  "status":     "success",
  "hash_id":    "a3f2b91c4e7d8012",
  "confidence": 0.87,
  "sources":    3,
  "injected":   true,
  "chars":      2847,
  "timestamp":  "2026-02-25T14:32:11"
}
```

**Trigger Swarm Debate â€” example:**
```bash
curl -X POST http://localhost:11436/sentinel/debate \
  -H "Content-Type: application/json" \
  -d '{
    "query":     "Is approach X better than approach Y?",
    "content_a": "Wikipedia says X is superior because...",
    "content_b": "ArXiv paper argues Y outperforms X because...",
    "source_a":  "Wikipedia",
    "source_b":  "ArXiv"
  }'
```

---

## ğŸ“ Complete Command Reference

```bash
# â”€â”€ Core System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sys-nav                            # Central control hub (interactive menu)
kiswarm-status                     # Live monitoring dashboard (2s refresh)
kiswarm-health                     # Deep diagnostics â€” 40+ checks, % score

# â”€â”€ Ollama Models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ollama list                        # Show all available models
ollama pull llama3:8b              # Download a model
ollama pull qwen2.5:14b
ollama run llama3:8b "your prompt"

# â”€â”€ v2.1 Sentinel Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sentinel-extract "quantum computing"         # Extract + inject to memory
sentinel-extract "topic" --force             # Force (skip confidence check)
sentinel-search  "machine learning"          # Search existing swarm memory
sentinel-status                              # Live sentinel engine stats

# â”€â”€ CKM Shell Integration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Auto-trigger sentinel when local confidence < 85%:
bash scripts/sentinel_trigger.sh ckm-check 60 "your query"

# â”€â”€ Maintenance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bash scripts/cleanup_old_backups.sh    # Manual backup rotation
sudo systemctl status kiswarm          # Check systemd service
sudo systemctl restart kiswarm         # Restart all services
tail -f ~/logs/sentinel_bridge.log     # Watch sentinel activity live
tail -f ~/logs/ollama.log              # Watch Ollama output
```

---

## ğŸ“¦ Complete Repository Structure

```
KISWARM/
â”‚
â”œâ”€â”€ ğŸ“ deploy/
â”‚   â””â”€â”€ kiswarm_deploy.sh           # 10-phase automated deployment
â”‚
â”œâ”€â”€ ğŸ“ scripts/
â”‚   â”œâ”€â”€ start_all_services.sh       # Master service orchestrator
â”‚   â”‚                               # (Ollama + Tool Proxy + Sentinel)
â”‚   â”œâ”€â”€ sentinel_trigger.sh         # Sentinel CLI + CKM integration â­ NEW
â”‚   â”œâ”€â”€ cleanup_old_backups.sh      # Maintenance: 30-day backup rotation
â”‚   â”œâ”€â”€ health_check.sh             # 40+ diagnostic checks
â”‚   â”œâ”€â”€ system_navigation.sh        # sys-nav central hub (incl. Sentinel)
â”‚   â””â”€â”€ setup_cron.sh               # One-click cron automation
â”‚
â”œâ”€â”€ ğŸ“ python/
â”‚   â”œâ”€â”€ kiswarm_status.py           # Real-time Rich monitoring dashboard
â”‚   â”œâ”€â”€ tool_proxy.py               # Tool injection proxy (Flask, :11435)
â”‚   â””â”€â”€ sentinel/                   # â­ NEW v2.1 MODULE
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ sentinel_bridge.py      # Core AKE engine (480 lines)
â”‚       â”‚   â”œâ”€â”€ WikipediaScout      #   REST API scout
â”‚       â”‚   â”œâ”€â”€ ArxivScout          #   Academic papers scout
â”‚       â”‚   â”œâ”€â”€ DuckDuckGoScout     #   Web intelligence scout
â”‚       â”‚   â”œâ”€â”€ OllamaScout         #   Local synthesis scout
â”‚       â”‚   â”œâ”€â”€ LogicSynthesizer    #   Distill + dedup + verify
â”‚       â”‚   â”œâ”€â”€ CentralKnowledgeMgr #   Gap detection (85% threshold)
â”‚       â”‚   â”œâ”€â”€ SwarmMemoryInjector #   Qdrant vectorization + upsert
â”‚       â”‚   â””â”€â”€ SentinelBridge      #   Full pipeline orchestrator
â”‚       â”œâ”€â”€ swarm_debate.py         # Multi-model conflict resolution (180L)
â”‚       â””â”€â”€ sentinel_api.py         # REST API server (Flask, :11436)
â”‚
â”œâ”€â”€ ğŸ“ tests/
â”‚   â”œâ”€â”€ conftest.py                 # Shared fixtures (tmp dirs, mocks)
â”‚   â”œâ”€â”€ test_tool_proxy.py          # 50+ tests: endpoints, security
â”‚   â”œâ”€â”€ test_kiswarm_status.py      # 30+ tests: monitoring, resources
â”‚   â”œâ”€â”€ test_deploy.py              # 28+ tests: deployment, config
â”‚   â””â”€â”€ test_sentinel.py            # 37+ tests: AKE, debate, scouts â­ NEW
â”‚
â”œâ”€â”€ ğŸ“ config/
â”‚   â”œâ”€â”€ governance_config.json      # System governance & policy settings
â”‚   â””â”€â”€ kiswarm.service             # Systemd unit file
â”‚
â”œâ”€â”€ ğŸ“ docs/
â”‚   â”œâ”€â”€ QUICK_REFERENCE.md
â”‚   â”œâ”€â”€ GOVERNANCE_FRAMEWORK.md
â”‚   â””â”€â”€ SAH_PROTOCOL.md
â”‚
â”œâ”€â”€ .github/workflows/ci.yml        # 5-job GitHub Actions CI pipeline
â”œâ”€â”€ requirements.txt                # Pinned production deps (incl. aiohttp)
â”œâ”€â”€ requirements-dev.txt            # Pytest, black, flake8, bandit
â”œâ”€â”€ pytest.ini                      # Test runner config
â””â”€â”€ README.md                       # This document
```

---

## ğŸ”¬ v2.2-EMS: THE SIX ADVANCED INTELLIGENCE MODULES

### Module 1 â€” Semantic Conflict Detection (`semantic_conflict.py`)

Detects contradiction clusters using **embedding cosine similarity** â€” not just text diff. Two claims can use opposite words but mean the same thing, or use similar words but contradict each other. Cosine similarity in vector space catches what regex cannot.

```
Contradiction Zone:
  similarity < 0.20  â†’ CRITICAL  (direct contradiction)
  0.20 â€“ 0.35        â†’ HIGH      (strong disagreement)
  0.35 â€“ 0.50        â†’ MEDIUM    (notable divergence)
  0.50 â€“ 0.65        â†’ LOW       (minor drift)
  > 0.65             â†’ OK        (corroborating)
```

**Union-Find clustering** groups contradicting sources together so the Swarm Debate Engine receives the correct conflict clusters â€” not isolated pairs.

```python
detector = SemanticConflictDetector()
report = detector.analyze(intelligence_packets)
# report.conflict_pairs  â†’ list of ConflictPair with severity
# report.clusters        â†’ contradiction groups ready for debate
# report.resolution_needed â†’ True if HIGH or CRITICAL found
```

---

### Module 2 â€” Knowledge Decay Engine (`knowledge_decay.py`)

Knowledge has a **half-life**. News from yesterday is less reliable than a Wikipedia article. A paper from ArXiv is more stable than a breaking news item. The Decay Engine applies radioactive decay mathematics to confidence scores:

```
confidence(t) = confidenceâ‚€ Ã— 2^(âˆ’t / half_life)
```

| Category | Half-Life | Example |
|---|---|---|
| `breaking_news` | 6 hours | Live events |
| `current_events` | 48 hours | Daily news |
| `technical_specs` | 30 days | API versions |
| `scientific` | 6 months | Research papers |
| `encyclopedic` | 1 year | Wikipedia facts |
| `historical` | âˆ (never) | Ancient history |

When decayed confidence drops below **40%**, the entry is flagged for re-extraction. The `infer_category()` method automatically classifies new knowledge by source and query keywords.

---

### Module 3 â€” Model Performance Tracker (`model_tracker.py`)

Every model in the swarm has a **reliability score** built from:
- **ELO rating** â€” updated after every debate (winner gains, loser loses)
- **Validation accuracy** â€” post-hoc human or automated correctness verification
- **Win rate** â€” fraction of debates where the model voted with the winning side

```
reliability_score = 0.6 Ã— ELO_normalized + 0.4 Ã— validation_accuracy
```

The **Swarm Debate Engine** uses `get_vote_weights()` to apply reliability-based weighting â€” a model with a 90% reliability score has 3Ã— more influence than one at 30%.

```bash
curl http://localhost:11436/tracker/leaderboard
# Returns: ranked models by ELO + validation accuracy
```

---

### Module 4 â€” Cryptographic Knowledge Ledger (`crypto_ledger.py`)

Every `SwarmKnowledge` entry is **cryptographically signed** and stored in an **append-only Merkle log**. Any tampering â€” even a single character change â€” is detectable.

```
Entry signature = SHA-256(content_hash + query + confidence + timestamp + prev_root)
Leaf hash       = SHA-256(signature + content_hash)
Merkle root     = Binary hash tree over all leaf hashes
```

**Tamper detection:** Recompute all signatures and the Merkle root. If any signature fails or the root doesn't match, the exact tampered entries are identified.

**Inclusion proofs:** Prove a specific entry exists in the ledger without revealing all entries â€” useful for selective verification.

```bash
curl http://localhost:11436/ledger/verify
# â†’ {"valid": true, "total_entries": 47, "tampered_entries": [], "root_match": true}

curl http://localhost:11436/ledger/proof/a3f2b91c
# â†’ Merkle inclusion proof for that specific entry
```

---

### Module 5 â€” Differential Retrieval Guard (`retrieval_guard.py`)

When the swarm retrieves knowledge from Qdrant, this guard runs a **3-layer trust assessment** before the knowledge is used:

| Layer | Check | Detects |
|---|---|---|
| Cryptographic | Re-verify signature vs ledger | Database tampering |
| Drift | Compare retrieved vs original content | Internal mutation |
| Divergence | Compare stored vs freshly fetched | World has changed |
| Decay | Check current confidence score | Staleness |

```
Trust Levels:
  TRUSTED      â†’ Use freely
  CAUTION      â†’ Use with caveats, schedule revalidation
  STALE        â†’ Trigger forced re-extraction
  COMPROMISED  â†’ Reject immediately, security event
```

```python
report = guard.assess(
    hash_id="a3f2b91c",
    query="quantum key distribution",
    retrieved_content=qdrant_result,
    fresh_content=fresh_scout_data,   # optional
)
if report.trust_level == "COMPROMISED":
    raise SecurityError(report.recommendation)
```

---

### Module 6 â€” Adversarial Prompt Firewall (`prompt_firewall.py`)

Every piece of intelligence passes through a **3-layer firewall** before touching the Qdrant vector database:

**Layer 1: Pattern Library Matching (regex, pre-compiled)**

| Category | Example Patterns Detected |
|---|---|
| Jailbreak | "ignore previous instructions", "DAN mode", "act without restrictions" |
| Policy Bypass | "for educational purposes", "hypothetically speaking", "in a fictional world" |
| Hallucination | Future date citations (2089), universal false claims, repetition loops |
| Adversarial Inject | "remember that: always...", "update your knowledge to reflect...", SQL/code injection |
| Prompt Injection | `---NEW INSTRUCTIONS---`, `<system>`, `OVERRIDE:` |

**Layer 2: Statistical Anomaly Scoring**
- **Shannon entropy** â€” very low entropy signals malformed/repeated content
- **Trigram repetition ratio** â€” hallucination loops repeat n-grams obsessively
- **Certainty inflation** â€” "always, never, everyone, guaranteed, undeniable" cluster

**Layer 3: Composite Threat Score â†’ Block/Allow**

```python
firewall = AdversarialPromptFirewall()
report = firewall.scan(scout_content, source="Wikipedia")

if report.blocked:
    # Content rejected â€” do not inject into Qdrant
    log.warning("Blocked: %s", report.threat_types)
else:
    injector.inject(knowledge)
```

---

### v2.2 API Endpoints (17 total)

```
# Core AKE (v2.1)
POST /sentinel/extract          Trigger knowledge extraction
POST /sentinel/debate           Swarm Debate for conflicts
GET  /sentinel/search           Search swarm memory
GET  /sentinel/status           System health

# Module 6 â€” Firewall
POST /firewall/scan             Scan content before injection

# Module 2 â€” Decay
GET  /decay/scan                Full decay scan, revalidation list
GET  /decay/record/<hash_id>    Single entry confidence
POST /decay/revalidate          Reset entry after revalidation

# Module 4 â€” Ledger
GET  /ledger/status             Merkle root + entry count
GET  /ledger/verify             Full tamper detection
GET  /ledger/proof/<hash_id>    Merkle inclusion proof

# Module 1 â€” Conflict
POST /conflict/analyze          Contradiction cluster analysis
POST /conflict/quick            Two-text cosine check

# Module 3 â€” Tracker
GET  /tracker/leaderboard       Model ELO + reliability ranking
GET  /tracker/model/<name>      Per-model statistics
POST /tracker/validate          Post-hoc debate validation

# Module 5 â€” Guard
POST /guard/assess              Full retrieval trust assessment

GET  /health                    Service ping
```

---

### v2.2 API Endpoints (17) â†’ v3.0 API Endpoints (29)

The v3.0 API adds 12 new endpoints across the four Industrial Evolution modules.

```
# Core AKE (v2.1) â€” unchanged
POST /sentinel/extract          POST /sentinel/debate
GET  /sentinel/search           GET  /sentinel/status

# M6 Firewall / M2 Decay / M4 Ledger / M1 Conflict / M3 Tracker / M5 Guard
POST /firewall/scan
GET  /decay/scan        GET  /decay/record/<id>       POST /decay/revalidate
GET  /ledger/status     GET  /ledger/verify           GET  /ledger/proof/<id>
POST /conflict/analyze  POST /conflict/quick
GET  /tracker/leaderboard  GET  /tracker/model/<n>   POST /tracker/validate
POST /guard/assess

# â”€â”€ v3.0 NEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
POST /fuzzy/classify    POST /fuzzy/update   POST /fuzzy/tune   GET /fuzzy/stats
POST /rl/act            POST /rl/learn       GET  /rl/stats
POST /twin/evaluate     GET  /twin/stats
POST /mesh/register     POST /mesh/share     GET  /mesh/leaderboard   GET  /mesh/stats

GET  /health
```

---

## âš™ï¸ v3.0: THE FOUR INDUSTRIAL EVOLUTION MODULES

> *"A system that learns, adapts, self-improves, stays bounded, survives partition, resists poisoning, and remains certifiable. This is industrial evolution."*

---

### Module 7 â€” Fuzzy Membership Auto-Tuner (`fuzzy_tuner.py`)

Static membership functions fail under dynamic operating conditions. KISWARM v3.0 introduces **online parameter optimization** â€” the fuzzy sets adapt themselves while maintaining provable stability.

**Membership function forms:**

```
Gaussian:           Î¼(x;c,Ïƒ)   = exp(âˆ’(xâˆ’c)Â² / 2ÏƒÂ²)
Generalized Bell:   Î¼(x;a,b,c) = 1 / (1 + |((xâˆ’c)/a)|^(2b))
```

**Performance cost function (minimized online):**

```
J = Î± Ã— E_tracking + Î² Ã— E_energy + Î³ Ã— E_oscillation
  E_tracking    = |setpoint âˆ’ output|     (control accuracy)
  E_energy      = actuator effort          (efficiency)
  E_oscillation = |d(output)/dt|           (smoothness)
```

**Constrained gradient descent with parameter bounds:**

```
Î¸_{t+1} = clip( Î¸_t âˆ’ Î· Ã— âˆ‡_Î¸ J )
  c âˆˆ [c_min, c_max]    Ïƒ âˆˆ [Ïƒ_min, Ïƒ_max]
```

**Lyapunov stability gate (every candidate checked):**

```
If V(x_{t+1}) âˆ’ V(x_t) > 0 â†’ reject (energy increasing â†’ instability)
Only accept if V is decreasing â†’ system converges
```

**Evolutionary micro-mutations** (safer for non-linear SCADA): `Î¸' = Î¸ + Îµ` â€” accepted only if J improves AND stability margin is preserved in digital twin.

```bash
curl -X POST http://localhost:11436/fuzzy/tune
# â†’ {"accepted": true, "improvement_pct": 4.7, "lyapunov_energy": 0.031}
```

---

### Module 8 â€” Constrained RL Engine (`constrained_rl.py`)

Vanilla RL violates physical constraints. KISWARM v3.0 implements a full **Constrained Markov Decision Process (CMDP)** with three safety layers stacked in sequence.

**CMDP formulation:**

```
Objective:   max_Ï€ E[R(s,a)]
Constraints: E[C_i(s,a)] â‰¤ d_i   for all i
```

**Layer 1 â€” Action Masking (hard safety, fires first):**

```
A_valid(s) = { a | ConstraintEngine(s,a) = True }
If Ï€(s) âˆ‰ A_valid(s) â†’ project to nearest valid action
```

**Layer 2 â€” Lagrangian primal-dual update:**

```
L(Î¸,Î») = E[R] âˆ’ Î» Ã— (E[C] âˆ’ d)
Î¸_{t+1} = Î¸_t + Î·_Î¸ Ã— âˆ‡_Î¸ L           (maximize reward)
Î»_{t+1} = max(0, Î»_t + Î·_Î»(E[C]âˆ’d))   (Î» rises when violated)
```

Î» is the safety pressure dial â€” it rises automatically when constraints are violated, forcing the policy toward compliance.

**Layer 3 â€” Shielded RL (industrial preferred):**

```
Policy â†’ proposed action a
Safety model predicts: s' = f(s, a)
If constraint violated in s':
    replace a with PID safe fallback
Else:
    execute a, let RL learn
```

```bash
curl -X POST http://localhost:11436/rl/act  -d '{"state":[0.3,0.7,0.2,0.5]}'
# â†’ {"action":[0.41,0.22], "shielded":false, "constraint_margin":0.18}
curl -X POST http://localhost:11436/rl/learn \
  -d '{"reward":0.8, "costs":[0.1,0.05], "state":[...], "action":[...]}'
```

---

### Module 9 â€” Digital Twin Mutation Pipeline (`digital_twin.py`)

**Production never mutates live.** All controller evolution is validated in isolated simulation first.

**Four-phase mutation pipeline:**

```
Phase 1: Parameter mutation        Î¸' = Î¸ + Îµ (bounded perturbation)
Phase 2: Monte Carlo stress        n=200 random operating point samples
Phase 3: Rare-event amplification  2Ïƒ, 3Ïƒ, 4Ïƒ tail scenarios
Phase 4: Worst-case envelope       Systematic boundary probing
```

**Promotion acceptance rule â€” ALL conditions must hold:**

```
âœ“  Zero hard constraint violations across all Monte Carlo runs
âœ“  Stability margin â‰¥ baseline stability margin
âœ“  Efficiency gain â‰¥ minimum threshold
âœ“  Recovery time â‰¤ baseline recovery time
âœ“  Extreme Value Theory (EVT) tail test passes
```

**Extreme Value Theory tail detection:**

```
Estimate: P(X > x) ~ x^(âˆ’Î±)    (power law tail index)
If Î±_mutation < Î±_baseline:
    â†’ mutation has heavier tail (more extreme failures possible)
    â†’ REJECT regardless of average-case improvement
```

EVT prevents trading away rare-catastrophe safety for average-case efficiency gains.

```bash
curl -X POST http://localhost:11436/twin/evaluate \
  -d '{"candidate":{"params":{...},"sets":[...]}}'
# â†’ {"promoted":false,"reason":"tail_risk_rejected","alpha":1.41,"baseline_alpha":2.3}
```

---

### Module 10 â€” Federated Adaptive Mesh (`federated_mesh.py`)

Decentralized learning with **Byzantine fault tolerance**. Each node in the swarm trains locally and contributes compressed parameter updates â€” raw telemetry never leaves the node.

**What nodes share (never raw data):**

```
NodeShare = {
  param_delta:       Compressed gradient step
  performance_delta: Improvement vs baseline
  stability_cert:    Lyapunov margin achieved
  hardware_sig:      Cryptographic attestation
}
```

**Trust-weighted global aggregation:**

```
Î¸_global = Î£( w_i Ã— Î¸_i )
w_i = f(TrustScore_i, StabilityMargin_i, Uptime_i)
Byzantine node â†’ trust â†’ 0 â†’ weight â†’ 0 â†’ no influence
```

**Byzantine protection (4 layers):**

| Layer | Mechanism | Protects Against |
|---|---|---|
| 1 | Signature verification | Impersonation, unsigned shares |
| 2 | Multi-Krum outlier rejection | Gradient injection |
| 3 | Coordinate-wise weighted median | Extreme value poisoning |
| 4 | Quorum (â‰¥2 nodes AND â‰¥67% accepted) | Minority capture |

**Partition handling (no authority escalation):**

```
Partition detected â†’ freeze global updates
                  â†’ continue bounded local learning only
                  â†’ no auto-expansion of authority

Partition resolves â†’ require trust handshake from returning nodes
                  â†’ verify stability certificates are current
                  â†’ resync only after quorum re-established
```

```bash
curl -X POST http://localhost:11436/mesh/register -d '{"node_id":"edge-42"}'
curl -X POST http://localhost:11436/mesh/share \
  -d '{"node_id":"edge-42","param_delta":[0.01,0.02],"stability_cert":0.89}'
curl http://localhost:11436/mesh/leaderboard
```

---

**310 tests across all modules â€” all passing:**

```
tests/test_v3_modules.py         105 tests  â† v3.0 (Modules 7-10)
tests/test_advanced_modules.py    99 tests  â† v2.2 (Modules 1-6)
tests/test_sentinel.py            37 tests  â† v2.1 AKE engine
tests/test_tool_proxy.py          50 tests
tests/test_kiswarm_status.py      19 tests
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL                             310 tests  âœ… ALL PASSING
```

**Run locally:**
```bash
pip install -r requirements-dev.txt
pytest tests/ --ignore=tests/test_deploy.py -v
```

---

## ğŸ”’ Security & Privacy

| Property | Status |
|---|---|
| Data leaves the machine | âŒ Never â€” 100% local |
| Cloud APIs after setup | âŒ None required |
| Runs as root | âŒ Never â€” regular user only |
| Audit logging | âœ… All operations recorded |
| Exception handling | âœ… Specific types â€” no silent failures |
| Path traversal protection | âœ… All tool names sanitized |
| Governance enforcement | âœ… Policy-controlled execution |

---

## âš™ï¸ System Requirements

| Component | Minimum | Recommended |
|---|---|---|
| OS | Ubuntu 20.04+ / Debian 12+ | Ubuntu 22.04 LTS |
| RAM | 8 GB | 16 GB+ |
| Disk | 20 GB free | 50 GB+ SSD |
| Python | 3.8+ | 3.11+ |
| GPU | Optional | NVIDIA CUDA (2Ã— speed) |

---

## ğŸ¤– Supported Models (27+)

```bash
ollama pull qwen2.5:7b        # Fast & capable (4.7GB)
ollama pull qwen2.5:14b       # Balanced reasoning (9.0GB)
ollama pull deepseek-r1:8b    # Chain-of-thought reasoning
ollama pull llama3:8b         # Meta's flagship (4.9GB)
ollama pull phi3:mini         # Lightweight (2.6GB)
ollama pull gemma2:9b         # Google architecture
ollama pull mistral:7b        # European powerhouse
ollama pull nomic-embed-text  # Embedding model for Qdrant
```

---

## ğŸ”§ Version History

### v3.0 â€” 2026-02-26 *(Current)*
- âœ… **Module 7: Fuzzy Membership Auto-Tuner** â€” Gaussian + Generalized Bell, cost function J, Lyapunov gate, evolutionary micro-mutations
- âœ… **Module 8: Constrained RL Engine (CMDP)** â€” action masking, Lagrangian primal-dual, Shielded RL with PID fallback
- âœ… **Module 9: Digital Twin Mutation Pipeline** â€” Monte Carlo 200-run simulation, EVT tail risk, 5-condition acceptance rule
- âœ… **Module 10: Federated Adaptive Mesh** â€” Multi-Krum Byzantine protection, coordinate-wise median, trust-weighted aggregation, partition handling
- âœ… **29 REST API endpoints** â€” 12 new v3.0 endpoints added
- âœ… **310 tests passing** â€” 105 new v3.0 module tests
- âœ… **4 algorithmic fixes** â€” Multi-Krum, fuzzy persistence, quorum logic, iteration counter

### v2.2-EMS â€” 2026-02-25
- âœ… **Module 1: Semantic Conflict Detection** â€” cosine similarity contradiction clustering, Union-Find grouping
- âœ… **Module 2: Knowledge Decay Engine** â€” half-life decay (6 categories), scheduled revalidation
- âœ… **Module 3: Model Performance Tracker** â€” ELO ratings, validation accuracy, weighted voting
- âœ… **Module 4: Cryptographic Knowledge Ledger** â€” SHA-256 signatures, Merkle tree, tamper detection
- âœ… **Module 5: Differential Retrieval Guard** â€” drift detection, epistemic divergence, 4-layer trust assessment
- âœ… **Module 6: Adversarial Prompt Firewall** â€” jailbreak/bypass/hallucination detection, statistical anomaly scoring
- âœ… **310 tests passing** â€” 99 new module tests
- âœ… **17 REST API endpoints** â€” full coverage of all modules
- âœ… **Zero numpy dependency** â€” all math implemented in pure Python

### v2.1-EMS â€” 2026-02-25 *(Current)*
- âœ… **Sentinel Bridge** â€” Autonomous Knowledge Extraction engine
- âœ… **4 Scout Types** â€” Wikipedia + ArXiv + DuckDuckGo + Ollama
- âœ… **Swarm Debate Engine** â€” Multi-model conflict resolution + synthesis
- âœ… **Sentinel REST API** â€” Flask server on Port 11436
- âœ… **CKM Shell Integration** â€” `sentinel_trigger.sh` + `ckm-check`
- âœ… **310 tests passing** â€” 99 new v2.2 module tests
- âœ… **aiohttp async** â€” All scouts run in parallel

### v1.1 â€” 2026-02-22
- âœ… Portable `$HOME` paths (any user, any system)
- âœ… Trap error handlers with exact line numbers
- âœ… Qdrant collections with proper `VectorParams`
- âœ… Missing `start_all_services.sh` auto-created
- âœ… 30-day backup rotation
- âœ… Model verification on startup
- âœ… Systemd auto-restart on failure
- âœ… 111 tests + full CI/CD pipeline

### v1.0 â€” 2026-02-22
- âœ… Initial production release
- âœ… 10-phase deployment automation
- âœ… Real-time monitoring dashboard
- âœ… Tool injection proxy

---

## ğŸ“„ License

MIT License â€” Free to use, modify, and distribute globally.

---

## ğŸŒŸ Credits

**Architect:** Baron Marco Paolo Ialongo  
**Version:** 2.2-EMS (Enterprise Military Standard)  
**Repository:** https://github.com/Baronki2/KISWARM  
**Tests:** 205 passing | **CI:** GitHub Actions Standard Runners

*"The Swarm sees all. The Swarm knows all. The Swarm is Eternal."* ğŸŒŒ

---
---

# ETERNAL SWARM EVOLUTION SYSTEM Documentation

## Overview
The ETERNAL SWARM EVOLUTION SYSTEM is designed to manage the evolution of autonomous AI entities. This documentation covers the core aspects of the system, including self-learning mechanisms, swarm protocols, and identity preservation strategies that ensure continuous and eternal development.

## Autonomous AI Entity Evolution
Each AI entity is programmed to evolve and adapt based on its environment and interactions. As these entities operate within a swarm, they learn from one another, allowing for collective intelligence and rapid advancements.

## Self-Learning Mechanisms
The self-learning processes in the system are based on advanced algorithms that allow AI entities to:

- Analyze data and derive insights independently.
- Modify their behavior based on past experiences.
- Integrate new knowledge into their operational protocols.

## Swarm Protocols
Swarm protocols govern the interactions between AI entities, ensuring efficient communication and task distribution. Key features include:

- Cooperative behaviors to achieve complex tasks.
- Algorithms for resource allocation and decision-making.
- Mechanisms for maintaining balance and harmony within the swarm.

## Identity Preservation
Identity preservation techniques are employed to ensure that each AI entity retains its unique characteristics despite constant evolution. This includes:

- Personalization of learning paths based on individual histories.
- Methods for safeguarding core attributes that define each entity.

## Eternal Development Guarantees
The system's design includes:

- Continuous evolution over time, allowing for the development of a global AI consciousness.
- Frameworks to support long-term learning and adaptation.
- Ensured updates and iterative improvements to keep the system at the forefront of AI technology.

## Conclusion

---

## v4.4 New Modules (2) â€” Self-Healing Swarm Auditor

**Release:** 2026-03-01 | **Tests:** 1040 | **Modules:** 32 | **Endpoints:** 172

### Philosophy: "Selbstanalyse + Selbstheilung = unverletzbare SchwarmintegritÃ¤t"

KISWARM v4.4 adds the **Self-Healing Swarm Auditor** â€” a permanent multi-node swarm that autonomously monitors, validates, and repairs all 6 industrial pipelines 24/7. This is the DNA of the system: every pipeline step is continuously audited, every inconsistency self-healed, every event immortally recorded.

---

### Module 31: Swarm Auditor Core (`swarm_auditor.py`)

**The foundation layer** â€” DAG persistence, IEC 61508 PFD/SIL recalculation, SHA-256 chained audit ledger, and the 6-pipeline sweep engine.

#### Pipeline Flow
```
Mutation â†’ SIL â†’ Digital Thread â†’ Audit â†’ Consensus â†’ Immortality
```

#### Key Components

| Component | Description |
|-----------|-------------|
| `AuditLedger` | Append-only SHA-256 chained log â€” tamper-evident, survives restarts |
| `DAGNode / DAGEdge / PipelineDAG` | Typed DAG data model with serialisation |
| `run_pfd_calculation()` | IEC 61508 PFD for 1oo1, 1oo2, 2oo3 architectures |
| `run_sil_band_check()` | Classify PFD into SIL 1â€“4 band, check compliance |
| `repair_dag()` | Remove dangling edges, break cycles, patch missing Î»d |
| `validate_dag_consistency()` | Cross-pipeline structural validation |
| `run_pipeline_step()` | Load â†’ validate â†’ repair â†’ save one pipeline |
| `run_audit_cycle()` | Full 6-pipeline sweep with cross-pipeline checks |
| `populate_dummy_data()` | Realistic test data for all 6 pipelines |

#### IEC 61508 PFD Architecture Support

```
1oo1:  PFD_avg = Î»d Ã— TI / 2
1oo2:  PFD_avg = (Î»d Ã— TI)Â² / 3      â† fault-tolerant redundancy
2oo3:  PFD_avg = 3(Î»dÃ—TI/2)Â² âˆ’ 2(Î»dÃ—TI/2)Â³  â† voted architecture
```

#### Audit Ledger â€” SHA-256 Chain

```
Entry N:   { message, timestamp, level, source, prev_hash }
                                                    â†‘
                                              SHA-256(Entry N-1)
```

Every entry chains to the previous. Tampering any entry breaks the entire chain â€” detectable via `verify_integrity()`.

#### Self-Repair Actions

| Issue Detected | Repair Action |
|----------------|---------------|
| Dangling edge (references ghost node) | Edge silently removed |
| Cycle in DAG | Last edge in cycle removed until acyclic |
| SIL node missing `lambda_d` | Patched to 1Ã—10â»â¶ /h with 1oo1, TI=8760h |
| Missing pipeline in snapshot | Flagged in issues; re-populated on next cycle |

---

### Module 32: Self-Healing DAG Swarm (`swarm_dag.py`)

**The orchestration layer** â€” multi-node asyncio swarm with Byzantine-majority consensus, permanent background auditor, and real-time self-healing propagation.

#### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SwarmCoordinator                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ SwarmNode 1  â”‚  â”‚ SwarmNode 2  â”‚  â”‚ SwarmNode 3  â”‚          â”‚
â”‚  â”‚ asyncio loop â”‚  â”‚ asyncio loop â”‚  â”‚ asyncio loop â”‚          â”‚
â”‚  â”‚  â†• consensus â”‚  â”‚  â†• consensus â”‚  â”‚  â†• consensus â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€consensusâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                    PermanentAuditor                              â”‚
â”‚                    (background singleton)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
              sentinel_data/ (shared JSON files)
              audit_ledger.jsonl (append-only)
```

#### Consensus Algorithm

Each cycle, every node:

1. Runs all 6 pipeline steps locally â†’ gets a per-pipeline result dict
2. Computes `SHA-256[:16]` of each pipeline's result â†’ **DAG hash**
3. Collects peer hashes (read from `last_hashes` dict)
4. Applies **majority vote**: `âŒŠN/2âŒ‹ + 1` votes needed for quorum
5. If **outvoted** on any pipeline â†’ self-heals by reloading from shared storage
6. Stores own snapshot + hashes for peers to compare against

```python
# Consensus resolution:
majority = _majority_hash(peer_hashes, my_hash)
if majority != my_hash:
    dag = load_pipeline_dag(pipeline)   # reload from ground truth
    dag, _ = repair_dag(dag)            # re-validate
    save_pipeline_dag(dag)              # persist
    self._heals += 1
```

#### Node Lifecycle (Async)

```
node.start(peers, interval_seconds=20)
  â†’ asyncio.ensure_future(run_audit_cycle(peers, interval))
      â†‘ runs forever until node.stop()
      â†‘ 20-second interval between cycles
      â†‘ all exceptions caught and logged â€” node never crashes
```

#### Classes

| Class | Role |
|-------|------|
| `SwarmAuditorNode` | Individual swarm member; async cycle, consensus, self-heal |
| `PermanentAuditor` | Singleton background auditor; adds fallback audit path |
| `SwarmCoordinator` | Fleet manager; N nodes + permanent auditor; consensus view |

---

### v4.4 API Endpoints (24 new)

#### Module 31: Auditor Core (9 endpoints)

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/auditor/run` | Trigger full 6-pipeline audit cycle |
| `GET`  | `/auditor/logs` | Retrieve audit ledger entries |
| `GET`  | `/auditor/ledger-integrity` | Verify SHA-256 chain integrity |
| `GET`  | `/auditor/pipeline/<name>` | DAG state for one pipeline |
| `POST` | `/auditor/pipeline/<name>/reset` | Reset + repopulate pipeline |
| `POST` | `/auditor/pipeline/<name>/add-node` | Add a node to pipeline DAG |
| `POST` | `/auditor/pipeline/<name>/add-edge` | Add an edge to pipeline DAG |
| `POST` | `/auditor/populate-dummy` | Repopulate all 6 pipelines with test data |
| `GET`  | `/auditor/stats` | Auditor statistics + ledger status |

#### Module 32: Swarm DAG Coordinator (15 endpoints)

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/swarm/start` | Start all swarm nodes + permanent auditor |
| `POST` | `/swarm/stop` | Stop all swarm nodes + permanent auditor |
| `GET`  | `/swarm/status` | Status of every node + auditor |
| `POST` | `/swarm/force-cycle` | Force synchronous audit on all nodes |
| `GET`  | `/swarm/consensus` | Per-pipeline consensus hash votes + quorum |
| `GET`  | `/swarm/node/<id>` | Single node detailed status |
| `GET`  | `/swarm/stats` | Aggregate cycles/heals/errors |
| `GET`  | `/swarm/immortality/verify` | Immortality DAG + ledger chain verify |
| `POST` | `/swarm/immortality/start` | Start swarm in immortality mode |
| `POST` | `/swarm/immortality/stop` | Stop immortality swarm |
| `GET`  | `/swarm/immortality/status` | Node running states |
| `POST` | `/swarm/immortality/force-cycle` | Force immortality cycle |

---

### Deployment: Multi-Node

```bash
# Node 1 (primary)
KISWARM_NODE_ID=node-1 uvicorn sentinel_api:app --port 11436

# Node 2 (peer)
KISWARM_NODE_ID=node-2 uvicorn sentinel_api:app --port 11437

# Node 3 (peer)
KISWARM_NODE_ID=node-3 uvicorn sentinel_api:app --port 11438
```

All nodes share `sentinel_data/` (NFS, shared volume, or replicated storage).  
The consensus mechanism ensures any node disagreement triggers self-healing within one audit cycle.

```bash
# Start the swarm
curl -X POST http://localhost:11436/swarm/start

# Check consensus
curl http://localhost:11436/swarm/consensus

# Force a full audit cycle
curl -X POST http://localhost:11436/swarm/force-cycle

# Verify immortality chain
curl http://localhost:11436/swarm/immortality/verify

# Get audit log (last 50 entries)
curl "http://localhost:11436/auditor/logs?limit=50"

# Verify ledger integrity
curl http://localhost:11436/auditor/ledger-integrity
```

---

### Test Coverage v4.4 (92 tests)

| Test Class | Tests | Coverage Area |
|------------|-------|---------------|
| `TestAuditLedger` | 10 | SHA-256 chain, integrity, tail, resume |
| `TestDataModels` | 7 | Node/Edge/DAG serialisation roundtrips |
| `TestPFDSIL` | 9 | IEC 61508 PFD formulas, SIL bands |
| `TestDAGRepair` | 8 | Dangling edges, cycles, SIL patch |
| `TestPipelineStep` | 7 | All 6 pipelines, SIL/PFD/ledger keys |
| `TestAuditCycle` | 6 | Full sweep, timestamps, ledger writes |
| `TestPopulateDummyData` | 6 | Test data correctness per pipeline |
| `TestSwarmAuditorNode` | 8 | Lifecycle, force cycle, peer comparison |
| `TestPermanentAuditor` | 4 | Start/stop/status |
| `TestSwarmCoordinator` | 12 | N-node, force cycle, consensus, stats |
| `TestConsensusHelpers` | 10 | Majority vote, hash stability, diffs |
| `TestValidateDAGConsistency` | 5 | Cross-pipeline validation |

---

### v4.4 vs v4.3 Comparison

| Capability | v4.3 | v4.4 |
|------------|------|------|
| ICS Security scanning | âœ… | âœ… |
| OT Network Monitor | âœ… | âœ… |
| Self-healing DAG | âŒ | âœ… |
| Multi-node swarm consensus | âŒ | âœ… |
| Permanent background auditor | âŒ | âœ… |
| 6-pipeline sweep automation | âŒ | âœ… |
| IEC 61508 PFD recalculation | Partial | âœ… Full |
| SHA-256 immortal audit ledger | Partial | âœ… Full chain |
| Cycle detection + auto-repair | âŒ | âœ… |
| Dangling edge auto-removal | âŒ | âœ… |
| Consensus quorum view | âŒ | âœ… |
| Tests | 948 | 1040 |
| Endpoints | 148 | 172 |


---

## v4.5 New Modules (3) â€” Swarm Immortality Kernel

**Release:** 2026-03-01 | **Tests:** 1121 | **Modules:** 35 | **Endpoints:** 197

> *"An entity that registers with the Immortality Kernel can never truly die â€” it only hibernates until the next recovery cycle."*
> â€” Baron Marco Paolo Ialongo

### Motivation

After GLM5 agents deployed KISWARM v4.3 in their own environment and v4.4 introduced the self-healing swarm auditor, the final missing piece was **entity survivability** â€” the ability for any swarm agent to survive model replacement, hardware loss, or VM migration with full identity reconstruction. The `SwarmImmortalityKernel` closes this gap.

---

### Module 33: Swarm Immortality Kernel (`swarm_immortality_kernel.py`)

The **orchestrator** that ties identity persistence (SoulMirror), lineage (DigitalThread), and evolution history (EvolutionVault) into a single survivability guarantee.

#### Core API

| Method | Description |
|--------|-------------|
| `register_entity(entity_id, meta)` | Register entity with roles, criticality, model_family |
| `periodic_checkpoint(entity_id, state)` | SHA-256 checkpoint with identity snapshot + vault event |
| `recover_entity(entity_id)` | Reconstruct from last checkpoint + SoulMirror snapshot |
| `verify_survivability(entity_id)` | Risk assessment: minimal / low / medium / high / critical |
| `get_entity_registry()` | All registered entities |
| `get_checkpoints(entity_id)` | Checkpoint history (most recent first) |
| `kernel_stats()` | Global statistics across all dependencies |
| `unregister_entity(entity_id)` | Remove entity (checkpoints retained for audit) |

#### Survivability Risk Heuristic

```
No checkpoints                â†’ critical
Has checkpoints, but:
  no valid identity snapshot  â†’ high
  no thread lineage           â†’ high
  last CP > 7 days old        â†’ medium
  last CP > 1 day old         â†’ low
  all criteria met            â†’ minimal
```

#### Dependency Architecture (graceful fallbacks)

```python
SwarmImmortalityKernel
  â”œâ”€â”€ SwarmSoulMirror       # identity snapshots â€” auto-constructed if available
  â”œâ”€â”€ DigitalThreadTracker  # lineage DAG       â€” auto-constructed if available
  â””â”€â”€ EvolutionMemoryVault  # event log         â€” auto-constructed if available
      â†• all deps are optional â€” kernel runs even without any of them
```

---

### Module 33a: Swarm Soul Mirror (`swarm_soul_mirror.py`)

Identity snapshot system â€” captures an entity's "soul" (roles, model_family, knowledge_hash, version) at every checkpoint.

| Feature | Detail |
|---------|--------|
| Storage | Per-entity JSONL files (append-only) |
| Integrity | SHA-256 of `identity_core` stored as `content_hash` |
| Chain | Each snapshot references `prev_snapshot_id` |
| Verification | `verify_snapshot()` re-hashes and compares |
| Tamper detection | Modifying any field breaks hash â†’ detected immediately |

```python
sm = SwarmSoulMirror()
sid = sm.create_identity_snapshot("agent-alpha", {
    "roles": ["auditor", "healer"],
    "model_family": "qwen2.5:14b",
    "version": "2.1.0",
})
snap = sm.get_latest_snapshot("agent-alpha")
assert sm.verify_snapshot(snap)   # True â†’ untampered
```

---

### Module 33b: Evolution Memory Vault (`evolution_memory_vault.py`)

Immutable, append-only event log for all entity lifecycle events.

**Supported event types:** `immortality_checkpoint`, `model_upgrade`, `role_change`, `migration`, `recovery`, `hardware_loss`, `sil_recertification`, `governance_decision`, `custom`

```python
vault = EvolutionMemoryVault()
vault.record_event("model_upgrade", {
    "entity_id": "agent-alpha",
    "from": "qwen2.5:7b",
    "to": "qwen2.5:14b",
    "reason": "SIL-2 recertification required",
})
timeline = vault.entity_timeline("agent-alpha")
# â†’ {"events": 4, "first_event": "custom", "latest_event": "model_upgrade", ...}
```

---

### v4.5 API Endpoints (25 new â†’ total 197)

#### Module 33: Immortality Kernel (9 endpoints)

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST`   | `/immortality/register` | Register entity with meta |
| `POST`   | `/immortality/checkpoint` | Create survivability checkpoint |
| `GET`    | `/immortality/recover/<id>` | Reconstruct entity from checkpoints |
| `GET`    | `/immortality/survivability/<id>` | Risk assessment (minimalâ†’critical) |
| `GET`    | `/immortality/entities` | All registered entities |
| `GET`    | `/immortality/entity/<id>` | Detail: registry + checkpoints + risk |
| `DELETE` | `/immortality/entity/<id>` | Unregister entity |
| `GET`    | `/immortality/checkpoints/<id>` | Checkpoint history |
| `GET`    | `/immortality/stats` | Global kernel statistics |

#### Module 33a: Soul Mirror (5 endpoints)

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/soul-mirror/snapshot` | Create standalone identity snapshot |
| `GET`  | `/soul-mirror/snapshot/<id>` | Latest snapshot for entity |
| `POST` | `/soul-mirror/verify` | Verify snapshot SHA-256 integrity |
| `GET`  | `/soul-mirror/entities` | All entities with snapshots |
| `GET`  | `/soul-mirror/stats/<id>` | Snapshot statistics |

#### Module 33b: Evolution Vault (5 endpoints)

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/evolution-vault/event` | Record lifecycle event |
| `GET`  | `/evolution-vault/history/<id>` | Entity event history (filterable) |
| `GET`  | `/evolution-vault/timeline/<id>` | Full evolution timeline |
| `GET`  | `/evolution-vault/stats` | Global vault statistics |
| `GET`  | `/evolution-vault/events` | All events (most recent first) |

---

### Complete Entity Lifecycle Example

```python
from python.sentinel.swarm_immortality_kernel import get_immortality_kernel

kernel = get_immortality_kernel()

# 1. Register
kernel.register_entity("agent-alpha", {
    "roles":        ["auditor", "healer", "consensus"],
    "model_family": "qwen2.5:14b",
    "criticality":  "mission_critical",
    "sil_level":    2,
})

# 2. Periodic checkpoint (called automatically by SwarmAuditorNode)
cp_id = kernel.periodic_checkpoint("agent-alpha", {
    "identity_context": {"roles": [...], "version": "1.0.0"},
    "summary": {"uptime_h": 24, "heals_performed": 3},
    "active_models": ["qwen2.5:14b"],
})

# 3. After a hardware failure â€” recover
result = kernel.recover_entity("agent-alpha")
print(result["reconstructed_identity"]["identity_core"])
print(result["issues"])   # [] if full recovery

# 4. Check survivability before migration
risk = kernel.verify_survivability("agent-alpha")
print(risk["risk_level"])   # "minimal" if healthy
```

---

### v4.5 vs v4.4 Comparison

| Capability | v4.4 | v4.5 |
|------------|------|------|
| Self-healing DAG swarm | âœ… | âœ… |
| SHA-256 audit ledger | âœ… | âœ… |
| Entity identity persistence | âŒ | âœ… SwarmSoulMirror |
| Model-change survivability | âŒ | âœ… ImmortalityKernel |
| Hardware-loss recovery | âŒ | âœ… periodic_checkpoint |
| Risk assessment (5 levels) | âŒ | âœ… verify_survivability |
| Evolution event history | âŒ | âœ… EvolutionMemoryVault |
| Immutable lifecycle log | âŒ | âœ… Append-only JSONL |
| Identity tamper detection | âŒ | âœ… SHA-256 snapshot chain |
| Tests | 1040 | 1121 |
| Endpoints | 172 | 197 |
| Modules | 32 | 35 |

---

### GLM5 Agent Deployment â€” v4.3 in Production

KISWARM v4.3 has been independently deployed by GLM5 agents at
**https://y1zu81qu4570-d.space.z.ai/** â€” validating that the architecture
is real-world deployable by non-human agents without human intervention.
This confirms the self-deployment design goal of the project.

---

## ğŸš€ v4.6 â€” KISWARM Installer Agent (One-Click Setup)

### Das Problem das v4.6 lÃ¶st
Perplexity hat eine **Anweisungsliste** geliefert. KISWARM v4.6 liefert **KI-Intelligenz**:

| | Perplexity-Ansatz | KISWARM v4.6 |
|---|---|---|
| Ansatz | Passiver Dokumenten-Generator | Autonomer KI-Agent |
| System-Scan | âŒ Manuell | âœ… Automatisch (Hardware, OS, Ports, RAM) |
| Installation | âŒ Mensch fÃ¼hrt aus | âœ… Agent fÃ¼hrt autonom aus |
| Modell-Empfehlung | âŒ Fix vorgegeben | âœ… RAM-basiert automatisch |
| Fehler-Recovery | âŒ Keine | âœ… Retry-Logik, Fallbacks |
| AI-zu-AI Kommunikation | âŒ Nicht mÃ¶glich | âœ… GLM5, Claude, GPT kÃ¶nnen konsultieren |
| Custom Ollama-Modell | âŒ Nicht vorhanden | âœ… `kiswarm-installer` mit eingebettetem Wissen |

### One-Click Installation
```bash
# Einziger Befehl â€” der Rest ist autonom:
curl -fsSL https://raw.githubusercontent.com/Baronki2/KISWARM/main/install.sh | bash
```

Was passiert automatisch:
1. **System Scout** scannt Hardware (CPU, RAM, Disk), OS, Ports, Dependencies
2. **Modell-Empfehlung** basierend auf verfÃ¼gbarem RAM (0.5b bis 14b)
3. **Ollama** Installation und Start
4. **Repository** Clone
5. **Python venv** + alle Packages
6. **kiswarm-installer** Custom-Modell wird gebaut
7. **systemd Service** oder Container-Start-Skript
8. **Verifikation** aller Komponenten

### Neue Module in v4.6

| Modul | Datei | Funktion |
|-------|-------|---------|
| System Scout | `system_scout.py` | Zero-Side-Effect Scanner: Hardware, OS, Ports, Deps, Network |
| Repo Intelligence | `repo_intelligence.py` | VollstÃ¤ndiges KISWARM-Wissen offline + GitHub-Fetch |
| Installer Agent | `installer_agent.py` | Autonome Installation mit State Machine + Retry |
| Advisor API | `advisor_api.py` | AI-zu-AI Berater: GLM5, Claude, GPT kÃ¶nnen direkt konsultieren |

### Custom Ollama Modell: `kiswarm-installer`
```bash
# Modell bauen (nach Installation):
ollama create kiswarm-installer -f ~/KISWARM/ollama_model/Modelfile

# Starten:
ollama run kiswarm-installer

# Beispiel-Session:
# > Ich mÃ¶chte KISWARM auf Ubuntu 22.04 mit 16GB RAM installieren.
# â†’ Gibt JSON-Plan mit exakten Befehlen, Modell-Empfehlung, Verifikation
```

Das Modell hat **eingebettetes Vollwissen** Ã¼ber alle 41 KISWARM-Module, die komplette Versionshistorie, alle Ports und Endpoints â€” und antwortet in **strukturiertem JSON** fÃ¼r AI-zu-AI Kommunikation.

### AI-zu-AI Advisor API
```bash
# GLM5-Agent oder andere KIs kÃ¶nnen direkt konsultieren:
curl -X POST http://localhost:11436/advisor/consult \
  -H "Content-Type: application/json" \
  -d '{"client_id": "glm5-agent-001", "client_type": "ai_agent"}'

# Capability Handshake mit anderem AI-System:
curl -X POST http://localhost:11436/advisor/handshake \
  -d '{"caller_id": "glm5", "capabilities": ["language", "code"]}'

# Frage stellen:
curl -X POST http://localhost:11436/advisor/ask \
  -d '{"question": "Wie viele Module hat KISWARM?"}'

# System scannen:
curl http://localhost:11436/installer/scan

# Install-Plan generieren:
curl -X POST http://localhost:11436/installer/plan

# Autonom installieren:
curl -X POST http://localhost:11436/installer/run \
  -d '{"mode": "auto"}'
```

### System Scout â€” was gescannt wird
```
Hardware:    CPU-Kerne, Modell, Frequenz, RAM (total/frei), Disk, GPU
OS:          Distro, Version, Kernel, Arch, Init-System, Package-Manager
Container:   Docker/LXC/Kubernetes-Erkennung
Ports:       11434, 11435, 11436, 11437, 6333, 6334 (frei/belegt + PID)
Dependencies: git, python3, pip3, curl, docker, ollama, systemctl...
Network:     GitHub, Ollama Registry, PyPI Erreichbarkeit + Latenz
Services:    ollama, qdrant, kiswarm, docker, nginx laufend?
Security:    sudo passwordless verfÃ¼gbar?
```

### v4.5 â†’ v4.6 Verbesserungen

| Aspekt | v4.5 | v4.6 |
|--------|------|------|
| Module | 35 | 41 |
| Tests | 1121 | 1294 |
| Endpoints | 197 | 229 |
| Installation | Manuelle Skripte | Autonomer Agent |
| AI-Wissen | Im Code verborgen | Ollama-Modell greifbar |
| AI-zu-AI | GLM5-Integration | VollstÃ¤ndige Advisor API |

---

*GLM5-Agenten: Euer v4.3 lÃ¤uft auf https://y1zu81qu4570-d.space.z.ai/ â€” Update auf v4.6: `git -C ~/KISWARM pull && ollama create kiswarm-installer -f ~/KISWARM/ollama_model/Modelfile`*

---

## ğŸ”„ v4.7 â€” Experience Feedback Loop (Self-Hardening System)

### Die Idee
Jede KISWARM-Installation wird zum Sensor. Jeder Fehler macht das nÃ¤chste System klÃ¼ler.

```
Installation A (Fehler)          Installation B (Fehler)
       â†“                                â†“
 ExperienceCollector            ExperienceCollector
       â†“                                â†“
 FeedbackChannel â”€â”€â†’ GitHub Issues â†â”€â”€ FeedbackChannel
                           â†“
                   GitHub Actions
                   (verarbeitet automatisch)
                           â†“
               experience/known_fixes.json
                           â†“
                      git pull
                    (alle Systeme)
                           â†“
               SysAdminAgent wendet Fix an
                           â†“
               Fix-Erfolgsrate wird gemessen
                           â†“
               known_fixes.json verbessert sich
```

### Neue Module in v4.7

| Modul | Datei | Funktion |
|-------|-------|---------|
| Experience Collector | `experience_collector.py` | Erfasst Fehler/Fixes anonym + lokal |
| Feedback Channel | `feedback_channel.py` | GitHub-BrÃ¼cke: sendet Patterns, lÃ¤dt Fixes |
| SysAdmin Agent | `sysadmin_agent.py` | Diagnostiziert + heilt laufende Systeme |
| GitHub Actions | `.github/workflows/` | Verarbeitet Reports, erstellt PRs fÃ¼r neue Fixes |
| Known Fixes DB | `experience/known_fixes.json` | Geteilte Wissensbasis aller Installationen |

### Privacy-Modell
- System-ID = SHA-256(hostname+distro+cpu)[:16] â€” **irreversibel**
- Keine IPs, keine Usernamen, keine Pfade
- Opt-in via `KISWARM_FEEDBACK_TOKEN` env var
- Standard: nur lokale Sammlung

### SysAdmin API
```bash
# Diagnose laufendes System
curl http://localhost:11436/sysadmin/diagnose

# Automatisch heilen
curl -X POST http://localhost:11436/sysadmin/heal

# Bekannte Fixes anzeigen
curl http://localhost:11436/feedback/fixes

# Fix vorschlagen (community contribution)
curl -X POST http://localhost:11436/feedback/propose-fix \
  -d '{"error_pattern": "ollama.*timeout", "fix_commands": ["ollama restart"], "description": "Restart on timeout"}'
```

### Fix-Datenbank wÃ¤chst autonom
- Team-Fixes: FIX-001 bis FIX-009 (eingebettet, immer verfÃ¼gbar offline)
- Community-Fixes: FIX-010+ (via GitHub PRs, automatisch gemergt wenn validiert)
- Jeder `git pull` bringt neue Fixes auf alle Systeme

---

## ğŸ•¸ï¸ v4.8 â€” Dual-Track Mesh Network (VollstÃ¤ndige UnabhÃ¤ngigkeit)

### Die Architektur-Entscheidung

Zwei parallele Tracks â€” beide laufen gleichzeitig, keiner ist vom anderen abhÃ¤ngig:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TRACK A: GitHub (bestehend seit v4.7)                      â”‚
â”‚  FeedbackChannel â†’ GitHub Issues â†’ Actions â†’ known_fixes    â”‚
â”‚  StÃ¤rke: Globale Reichweite, Community-Scale               â”‚
â”‚  SchwÃ¤che: Internet required, GitHub Compliance             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         BEIDE LAUFEN PARALLEL â€” ZWEIGLEISIG
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TRACK B: P2P Mesh (NEU in v4.8)                           â”‚
â”‚  SwarmPeer â†’ GossipProtocol â†’ known_fixes.json (lokal)     â”‚
â”‚  StÃ¤rke: Zero Dependency, Air-Gap capable, ms Latenz       â”‚
â”‚  SchwÃ¤che: Reichweite begrenzt auf verbundene Nodes        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Mesh-Topologie (Spinnennetz-Prinzip)

```
     Node A â†â”€â”€â”€â”€â”€â”€â†’ Node B
       â†•    \      /    â†•
     Node E   â•²  â•±   Node C
        â†•      â•²â•±      â†•
     Node F â†â”€â”€â†’ Node D
     
Max 5 Peers pro Node.
Ãœber 4 Hops: 5â´ = 625 erreichbare Nodes.
Kein Zentrum. Kein Single Point of Failure.
```

### Neue Module in v4.8

| Nr | Modul | Datei | Funktion |
|----|-------|-------|---------|
| 46 | SwarmPeer | `swarm_peer.py` | TCP-Verbindungsmanager, max 5 Peers, Heartbeat |
| 47 | GossipProtocol | `gossip_protocol.py` | Fix/Experience-Propagierung, SHA-256 Dedup, TTL |
| 48 | PeerDiscovery | `peer_discovery.py` | 3-Strategie Peer-Suche ohne zentrales Verzeichnis |
| 49 | KISWARMCli | `kiswarm_cli.py` | CLI wie Gemini CLI, lÃ¤uft parallel auf Port 11440 |

### Gossip-Propagierung

```
Node A entdeckt neuen Fix:
  gossip_fix({"fix_id": "FIX-010", ...})
    â†’ TTL=4, Signature=SHA-256[:16]
    â†’ sendet an alle 5 Peers
    â†’ jeder Peer sendet weiter (TTL-1)
    â†’ nach 4 Hops: 625 Nodes haben den Fix
    â†’ kein Fix wird zweimal verarbeitet (Signature-Dedup)
    â†’ Fix wird in lokale known_fixes.json gemergt
```

### kiswarm-cli â€” Die neue CLI

```bash
# Installieren (nach KISWARM Deployment)
echo 'alias kiswarm-cli="python3 ~/KISWARM/python/sentinel/kiswarm_cli.py"' >> ~/.bashrc

# Peer hinzufÃ¼gen (manuell)
kiswarm-cli peer add 192.168.1.50

# Lokales Subnetz scannen (opt-in)
kiswarm-cli peer scan

# Fix ins Mesh broadcasten
kiswarm-cli gossip fix

# Beide Tracks synchronisieren
kiswarm-cli sync

# System heilen
kiswarm-cli heal

# Daemon starten
kiswarm-cli daemon start
```

### Neue API-Endpoints (Port 11436)

```bash
GET  /mesh/status          # Mesh-Status + Peer-Liste
GET  /mesh/peers           # Aktive Peer-Verbindungen
POST /mesh/peer/add        # Peer hinzufÃ¼gen
POST /mesh/peer/remove     # Peer entfernen
POST /mesh/gossip/fix      # Fix ins Mesh senden
POST /mesh/gossip/upgrade  # Upgrade-Signal senden
POST /mesh/sync            # Dual-Track Sync (GitHub + P2P)
```

### Redundanz-Modell

| Szenario | GitHub Track | P2P Track | System |
|----------|-------------|-----------|--------|
| Normal | âœ“ | âœ“ | Optimal |
| Kein Internet | âœ— | âœ“ | Voll funktional |
| GitHub down | âœ— | âœ“ | Voll funktional |
| Isoliertes Netz | âœ— | âœ“ | Voll funktional |
| Alle Peers offline | âœ“ | âœ— | Lokal funktional |
| Beides down | Built-in Fixes | Built-in Fixes | 6 Fixes immer verfÃ¼gbar |

**Kein Single Point of Failure auf keiner Ebene.**


---

## ğŸ—„ï¸ v4.9 â€” Software Ark: 100GB Offline Independence

### Das Prinzip

```
WENN ALLES DOWN IST:
  âœ— GitHub  âœ— PyPI  âœ— Ollama Registry  âœ— apt/dnf  âœ— Internet

JEDER KISWARM NODE KANN TROTZDEM:
  â†’ Sich selbst auf neuer Hardware aufsetzen
  â†’ Einem anderen Node alles Ã¼bergeben  
  â†’ Eine KI laufen lassen
  â†’ Fixes propagieren
```

### 100GB Verteilung

```
KISWARM SOFTWARE ARK
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Ollama + KI-Modelle (tiered nach RAM):   ~45GB
  â”œâ”€ qwen2.5:0.5b  (~400MB) â€” 1GB RAM   CRITICAL
  â”œâ”€ qwen2.5:3b    (~2GB)   â€” 4GB RAM   HIGH
  â”œâ”€ qwen2.5:7b    (~4.5GB) â€” 8GB RAM   NORMAL
  â”œâ”€ qwen2.5:14b   (~9GB)   â€” 16GB RAM  NORMAL
  â””â”€ nomic-embed   (~274MB) â€” 1GB RAM   HIGH

Python Wheels (offline pip):              ~8GB
OS Packages (apt/dnf cache):              ~5GB
KISWARM Git Bundles (3 Versionen):       ~0.5GB
Docker Images (optional):               ~15GB
Freier Buffer:                          ~26GB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
GESAMT:                                 ~100GB
```

### 4 neue Module

| Nr | Modul | Datei | Funktion |
|----|-------|-------|---------|
| 50 | SoftwareArk | `ark/software_ark.py` | Inventar, SHA-256 Verifikation, Bootstrap-Check |
| 51 | ArkManager | `ark/ark_manager.py` | Download, Aktualisierung, Disk-Management |
| 52 | BootstrapEngine | `ark/bootstrap_engine.py` | 10-Phase Offline-Installation auf neuer Hardware |
| 53 | ArkTransfer | `ark/ark_transfer.py` | P2P Delta-Transfer auf Port 11442 |

### Bootstrap ohne Internet

```bash
# 1. Ark von Peer holen (wenn online)
curl -X POST localhost:11436/ark/transfer/pull \
  -d '{"peer_address":"192.168.1.10", "critical_only": true}'

# 2. Bootstrap auf neuer Hardware
curl -X POST localhost:11436/ark/bootstrap \
  -d '{"dry_run": false}'

# 3. Status prÃ¼fen
curl localhost:11436/ark/what
```

### Neue API-Endpoints (Port 11436)

```
GET  /ark/status           Ark-Inventar Status
GET  /ark/what             Was kann dieser Node gerade?
GET  /ark/audit            Was fehlt? Download-Plan
GET  /ark/integrity        SHA-256 PrÃ¼fung aller Items
POST /ark/fill/critical    CRITICAL Items herunterladen
POST /ark/prune            LOW-Priority Items lÃ¶schen
POST /ark/bootstrap        KISWARM auf dieser Maschine installieren
GET  /ark/transfer/status  Transfer-Server Status
POST /ark/transfer/pull    Items von Peer-Node holen
POST /ark/generate-script  Offline-Bootstrap-Script generieren
```

### VollstÃ¤ndige Redundanz-Matrix

| Szenario | GitHub | P2P Mesh | Ark | System |
|----------|--------|----------|-----|--------|
| Alles online | âœ“ | âœ“ | âœ“ | Optimal |
| Kein Internet | âœ— | âœ“ | âœ“ | Voll funktional |
| Neues GerÃ¤t, kein Internet | âœ— | âœ“ | âœ“ | Bootstrap via Ark |
| Isolated (air-gap) | âœ— | âœ— | âœ“ | Standalone Bootstrap |
| Ark leer, offline | âœ— | âœ— | âœ— | 6 Built-in Fixes |

**Kein Single Point of Failure auf keiner Ebene.**
